
logging 

# -----------------------------
# DEBUG CONFIG
# -----------------------------

DEBUG_MODE = os.getenv("INGEST_DEBUG", "false").lower() == "true"
DEBUG_SQL  = os.getenv("INGEST_DEBUG_SQL", "false").lower() == "true"

logging.basicConfig(
    level=logging.DEBUG if DEBUG_MODE else logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)]
)

log = logging.getLogger("INGEST")


def dbg(msg: str):
    if DEBUG_MODE:
        log.debug(msg)

def info(msg: str):
    log.info(msg)

def warn(msg: str):
    log.warning(msg)

def err(msg: str):
    log.error(msg)

def ingest_project(project_dir: str):
    project = os.path.basename(project_dir)

    info(f"[PROJECT] {project}")

    for xml_file in glob.glob(os.path.join(project_dir, "*.xml")):
        info(f"  ‚Üí Parsing {xml_file}")

        tree = etree.parse(xml_file)
        root = tree.getroot()

        for mpu_node in root.findall(".//MPU"):
            mpu_name = mpu_node.get("name")

            if not mpu_name:
                err("MPU node found without name attribute")
                raise RuntimeError("MPU node found without name attribute")

            info(f"    [MPU] {mpu_name}")

            for prtn_node in mpu_node.findall(".//PRTn"):
                prtn = parse_prtn(prtn_node)

                dbg(
                    f"      [RG {prtn['rg_index']}] "
                    f"profile={prtn['profile']} "
                    f"start={prtn['start_hex']} end={prtn['end_hex']}"
                )

                ingest_prtn(project, mpu_name, prtn)

def ingest_prtn(project: str, mpu_name: str, prtn: Dict[str, Any]):

    rg_index = prtn["rg_index"]
    profile  = prtn["profile"]
    raw_xml  = prtn["raw_xml"]
    xml_hash = sha256(raw_xml)

    dbg(f"[CHECK] {project}/{mpu_name}/RG{rg_index}/{profile}")

    # -----------------------------
    # 1Ô∏è‚É£ SAME VERSION GUARD
    # -----------------------------

    same_version = pg_fetch_one(
        """
        SELECT chunk_id, xml_hash, is_active
        FROM policy_chunks
        WHERE project=%s
          AND branch='main'
          AND mpu_name=%s
          AND rg_index=%s
          AND COALESCE(profile,'')=COALESCE(%s,'')
          AND policy_version=%s
        """,
        (project, mpu_name, rg_index, profile, POLICY_VERSION)
    )

    if same_version:
        chunk_id, old_hash, is_active = same_version

        dbg(
            f"[FOUND-SAME-VERSION] RG{rg_index} "
            f"hash_db={old_hash[:12]} hash_xml={xml_hash[:12]} "
            f"active={is_active}"
        )

        if old_hash == xml_hash:
            info(f"      ‚è≠Ô∏è SKIP RG {rg_index} (same version, unchanged)")
            return

        # Illegal mutation
        err(
            f"üî• ILLEGAL CHANGE: {project}/{mpu_name}/RG{rg_index}/{profile} "
            f"modified without version bump"
        )
        raise RuntimeError(
            f"Policy modified without version bump: "
            f"{project}/{mpu_name}/RG{rg_index}/{profile}"
        )

    # -----------------------------
    # 2Ô∏è‚É£ FIND CURRENT ACTIVE POLICY
    # -----------------------------

    active_row = pg_fetch_one(
        """
        SELECT chunk_id, xml_hash
        FROM policy_chunks
        WHERE project=%s
          AND mpu_name=%s
          AND rg_index=%s
          AND COALESCE(profile,'')=COALESCE(%s,'')
          AND is_active=true
        """,
        (project, mpu_name, rg_index, profile)
    )

    if active_row:
        old_chunk_id, old_hash = active_row

        dbg(
            f"[ACTIVE-FOUND] RG{rg_index} "
            f"old_chunk={old_chunk_id}"
        )

        info(f"      ‚ôªÔ∏è UPDATE RG {rg_index}")

        # Deactivate previous
        pg_execute(
            "UPDATE policy_chunks SET is_active=false WHERE chunk_id=%s",
            (old_chunk_id,)
        )

        delete_weaviate_vector(old_chunk_id)

        new_chunk_id = str(uuid.uuid4())
        insert_new_policy(
            project, mpu_name, prtn,
            xml_hash, new_chunk_id,
            supersedes=old_chunk_id
        )

        info(f"      ‚úÖ Inserted new RG {rg_index} (ACTIVE)")
        return

    # -----------------------------
    # 3Ô∏è‚É£ FIRST INSERT
    # -----------------------------

    info(f"      ‚úÖ INSERT RG {rg_index} (first seen)")

    new_chunk_id = str(uuid.uuid4())
    insert_new_policy(
        project, mpu_name, prtn,
        xml_hash, new_chunk_id
    )

def pg_execute(query: str, params: tuple):
    if DEBUG_SQL:
        dbg(f"[SQL] {query.strip()} | params={params}")
    cur = pg.cursor()
    cur.execute(query, params)

def pg_fetch_one(query: str, params: tuple):
    if DEBUG_SQL:
        dbg(f"[SQL] {query.strip()} | params={params}")
    cur = pg.cursor()
    cur.execute(query, params)
    return cur.fetchone()









CREATE TABLE policy_chunks (

    chunk_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

    project TEXT NOT NULL,
    branch  TEXT DEFAULT 'main',
    file_path TEXT,
    file_version TEXT,
    policy_version TEXT NOT NULL,
    xml_path TEXT,

    mpu_name TEXT NOT NULL,
    rg_index INT  NOT NULL,
    profile  TEXT,

    policy_id    TEXT,
    policy_title TEXT,

    start_dec BIGINT,
    end_dec   BIGINT,
    start_hex TEXT,
    end_hex   TEXT,

    rdomains TEXT[],
    wdomains TEXT[],
    rvmids   TEXT[],
    wvmids   TEXT[],

    static    BOOLEAN,
    confirmed BOOLEAN,
    enabled   BOOLEAN,

    raw_xml  TEXT NOT NULL,
    xml_hash TEXT NOT NULL,

    is_active BOOLEAN NOT NULL DEFAULT true,
    supersedes_chunk_id UUID NULL,

    weaviate_object_id UUID UNIQUE NOT NULL,

    created_at TIMESTAMP DEFAULT NOW(),

    UNIQUE (project, branch, mpu_name, rg_index, profile, policy_version)
);

CREATE INDEX idx_active_policy
ON policy_chunks(project, branch, mpu_name, rg_index, profile)
WHERE is_active = true;

CREATE INDEX idx_project_mpu
ON policy_chunks(project, mpu_name);

CREATE INDEX idx_addr_range
ON policy_chunks(start_dec, end_dec);

CREATE INDEX idx_weaviate_id
ON policy_chunks(weaviate_object_id);

CREATE INDEX idx_xml_hash
ON policy_chunks(xml_hash);












export PG_HOST=localhost
export PG_DB=ragdb
export PG_USER=raguser
export PG_PASSWORD=ragpass
export WEAVIATE_URL=http://localhost:8080
export POLICY_VERSION=v1.0    # change per ingestion


class PropagateRequest(BaseModel):
    parent_project: str
    child_project: str
    mpu_name: Optional[str] = None   # null = all MPUs


def pg_get_active_policies(project: str, mpu_name: Optional[str] = None):
    sql = """
    SELECT *
    FROM policy_chunks
    WHERE project = %s
      AND is_active = true
      AND (%s IS NULL OR mpu_name = %s)
    ORDER BY mpu_name, rg_index, profile;
    """

    params = (project, mpu_name, mpu_name)
    return pg_fetch_rows(sql, params)


def logical_key(row: Dict[str, Any]):
    """
    Logical policy identity for propagation & diff.
    """
    return (row["mpu_name"], row["rg_index"], row.get("profile"))


@app.post("/propagate")
def propagate_policies(req: PropagateRequest):
    """
    Parent ‚Üí Child policy propagation planner.

    Returns:
      - propagate_missing : policies present in parent but missing in child
      - propagate_review  : policies present in both but with different rules
    """

    parent_rows = pg_get_active_policies(req.parent_project, req.mpu_name)
    child_rows  = pg_get_active_policies(req.child_project,  req.mpu_name)

    parent_map = {logical_key(r): r for r in parent_rows}
    child_map  = {logical_key(r): r for r in child_rows}

    propagate_missing = []
    propagate_review  = []

    compare_fields = [
        "start_dec",
        "end_dec",
        "rdomains",
        "wdomains",
        "rvmids",
        "wvmids",
        "static",
        "confirmed",
        "enabled",
    ]

    for key, parent_row in parent_map.items():
        child_row = child_map.get(key)

        # -----------------------------
        # Case 1: Missing in Child ‚Üí MUST PROPAGATE
        # -----------------------------
        if not child_row:
            propagate_missing.append(
                {
                    "mpu_name": parent_row["mpu_name"],
                    "rg_index": parent_row["rg_index"],
                    "profile": parent_row.get("profile"),
                    "parent_policy": parent_row,
                }
            )
            continue

        # -----------------------------
        # Case 2: Exists in both ‚Üí CHECK FOR DIFFERENCES
        # -----------------------------
        diffs = {}
        for f in compare_fields:
            if parent_row[f] != child_row[f]:
                diffs[f] = {
                    req.parent_project: parent_row[f],
                    req.child_project:  child_row[f],
                }

        if diffs:
            propagate_review.append(
                {
                    "mpu_name": parent_row["mpu_name"],
                    "rg_index": parent_row["rg_index"],
                    "profile": parent_row.get("profile"),
                    "diffs": diffs,
                    "parent_policy": parent_row,
                    "child_policy": child_row,
                }
            )

    return {
        "parent_project": req.parent_project,
        "child_project": req.child_project,
        "mpu_name": req.mpu_name,
        "propagate_missing": propagate_missing,
        "propagate_review": propagate_review,
        "summary": {
            "missing_count": len(propagate_missing),
            "review_count": len(propagate_review),
        },
    }

