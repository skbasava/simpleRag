
from weaviate.classes.config import (
    Configure,
    Property,
    DataType,
)

def ensure_schema(client):
    if client.collections.exists("PolicyChunks"):
        return

    client.collections.create(
        name="PolicyChunks",
        vectorizer_config=Configure.Vectorizer.none(),
        properties=[
            # ---------- INT fields (filterable ONLY) ----------
            Property(
                name="chunk_id",
                data_type=DataType.INT,
                index_filterable=True,
                index_searchable=False,   # üîë REQUIRED
            ),
            Property(
                name="rg_index",
                data_type=DataType.INT,
                index_filterable=True,
                index_searchable=False,   # üîë REQUIRED
            ),

            # ---------- TEXT fields ----------
            Property(
                name="project",
                data_type=DataType.TEXT,
                index_filterable=True,
                index_searchable=True,
            ),
            Property(
                name="version",
                data_type=DataType.TEXT,
                index_filterable=True,
                index_searchable=True,
            ),
            Property(
                name="mpu_name",
                data_type=DataType.TEXT,
                index_filterable=True,
                index_searchable=True,
            ),
            Property(
                name="profile",
                data_type=DataType.TEXT,
                index_filterable=True,
                index_searchable=True,
            ),
            Property(
                name="start_hex",
                data_type=DataType.TEXT,
                index_filterable=True,
                index_searchable=False,
            ),
            Property(
                name="end_hex",
                data_type=DataType.TEXT,
                index_filterable=True,
                index_searchable=False,
            ),

            # ---------- Vector payload ----------
            Property(
                name="chunk_text",
                data_type=DataType.TEXT,
                index_searchable=True,
            ),
        ],
    )






from weaviate.classes.config import (
    Configure,
    Property,
    DataType,
)

def ensure_schema(client):
    if client.collections.exists("PolicyChunks"):
        return

    client.collections.create(
        name="PolicyChunks",
        vectorizer_config=Configure.Vectorizer.none(),
        properties=[
            # IDs / filters (NOT tokenized)
            Property(
                name="chunk_id",
                data_type=DataType.INT,
                index_filterable=True,
                index_searchable=False,
            ),
            Property(
                name="rg_index",
                data_type=DataType.INT,
                index_filterable=True,
                index_searchable=False,
            ),

            # Text fields (tokenized)
            Property(
                name="project",
                data_type=DataType.TEXT,
                index_filterable=True,
                index_searchable=True,
            ),
            Property(
                name="version",
                data_type=DataType.TEXT,
                index_filterable=True,
                index_searchable=True,
            ),
            Property(
                name="mpu_name",
                data_type=DataType.TEXT,
                index_filterable=True,
                index_searchable=True,
            ),
            Property(
                name="profile",
                data_type=DataType.TEXT,
                index_filterable=True,
                index_searchable=True,
            ),
            Property(
                name="start_hex",
                data_type=DataType.TEXT,
                index_filterable=True,
                index_searchable=False,
            ),
            Property(
                name="end_hex",
                data_type=DataType.TEXT,
                index_filterable=True,
                index_searchable=False,
            ),

            # Vector payload
            Property(
                name="chunk_text",
                data_type=DataType.TEXT,
                index_searchable=True,
            ),
        ],
    )





from weaviate.classes.config import Configure, Property, DataType

def ensure_schema(client):
    if client.collections.exists("PolicyChunks"):
        return

    client.collections.create(
        name="PolicyChunks",
        vectorizer_config=Configure.Vectorizer.none(),
        properties=[
            Property(name="chunk_id", data_type=DataType.INT),
            Property(name="project", data_type=DataType.TEXT),
            Property(name="version", data_type=DataType.TEXT),
            Property(name="mpu_name", data_type=DataType.TEXT),
            Property(name="rg_index", data_type=DataType.INT),
            Property(name="profile", data_type=DataType.TEXT),
            Property(name="start_hex", data_type=DataType.TEXT),
            Property(name="end_hex", data_type=DataType.TEXT),
            Property(name="chunk_text", data_type=DataType.TEXT),
        ],
    )


import os
import uuid
import weaviate
from weaviate.connect import ConnectionParams

class WeaviateDriver:
    def __init__(self):
        weaviate_url = os.environ.get("WEAVIATE_URL", "http://rag-weaviate:8080")

        self.client = weaviate.WeaviateClient(
            connection_params=ConnectionParams.from_url(
                weaviate_url,
                grpc_port=50051,
            )
        )
        self.client.connect()

        self.collection = self.client.collections.get("PolicyChunks")

    def close(self):
        self.client.close()

    def insert_vector(self, *, vector, properties) -> str:
        wid = str(uuid.uuid4())
        self.collection.data.insert(
            uuid=wid,
            vector=vector,
            properties=properties,
        )
        return wid

    def semantic_search(self, vector, limit=10, filters=None):
        return self.collection.query.near_vector(
            near_vector=vector,
            limit=limit,
            filters=filters,
            return_metadata=["distance"],
        )



from typing import List
from app.rag.models import Chunk

class PostgresDriver:
    def structured_search(self, filters: dict, limit: int = 20) -> List[Chunk]:
        sql = """
        SELECT
            id,
            project,
            mpu_name,
            rg_index,
            profile,
            start_hex,
            end_hex,
            chunk_text
        FROM policy_chunks
        WHERE is_active = TRUE
          AND (%(project)s IS NULL OR project = %(project)s)
          AND (%(mpu_name)s IS NULL OR mpu_name = %(mpu_name)s)
          AND (%(rg_index)s IS NULL OR rg_index = %(rg_index)s)
          AND (%(profile)s IS NULL OR profile = %(profile)s)
        ORDER BY rg_index, chunk_index
        LIMIT %(limit)s
        """

        params = {
            "project": filters.get("project"),
            "mpu_name": filters.get("mpu_name"),
            "rg_index": filters.get("rg_index"),
            "profile": filters.get("profile"),
            "limit": limit,
        }

        rows = self.fetch_all(sql, params)

        return [
            Chunk(
                chunk_id=row["id"],
                project=row["project"],
                mpu_name=row["mpu_name"],
                rg_index=row["rg_index"],
                profile=row["profile"],
                start_hex=row["start_hex"],
                end_hex=row["end_hex"],
                chunk_text=row["chunk_text"],
                source="postgres",
            )
            for row in rows
        ]




def wv_obj_to_chunk(obj, score: float) -> Chunk:
    return Chunk(
        chunk_id=int(obj.properties["chunk_id"]),
        project=obj.properties["project"],
        mpu_name=obj.properties["mpu_name"],
        rg_index=obj.properties["rg_index"],
        profile=obj.properties["profile"],
        start_hex=obj.properties["start_hex"],
        end_hex=obj.properties["end_hex"],
        chunk_text=obj.properties["chunk_text"],
        source="weaviate",
        score=score,
     )
def pg_row_to_chunk(row) -> Chunk:
    return Chunk(
        chunk_id=row["id"],
        project=row["project"],
        mpu_name=row["mpu_name"],
        rg_index=row["rg_index"],
        profile=row["profile"],
        start_hex=row["start_hex"],
        end_hex=row["end_hex"],
        chunk_text=row["chunk_text"],
        source="postgres",
        score=None,
    )


import os
from dataclasses import dataclass


@dataclass(frozen=True)
class Settings:
    PG_DSN: str
    WEAVIATE_URL: str

    @staticmethod
    def load() -> "Settings":
        return Settings(
            PG_DSN=os.environ["PG_DSN"],
            WEAVIATE_URL=os.environ["WEAVIATE_URL"],
        )


settings = Settings.load()



rag-system/
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ README.md
‚îÇ
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ main.py                     # FastAPI entrypoint (uvicorn.run)
‚îÇ   ‚îú‚îÄ‚îÄ api.py                      # /query endpoint, FastAPI app
‚îÇ   ‚îú‚îÄ‚îÄ chainlit_app.py             # Chainlit UI client
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ ingest.py                   # Job-based ingestion runner
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ settings.py             # env vars (PG_DSN, WEAVIATE_URL)
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ postgres.py             # pgConnect + helpers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ weaviate.py              # WeaviateClient wrapper
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ weaviate_schema.py       # ensure_schema()
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ ingestion/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ state_machine.py         # ingest_one_file(), ingest_chunks()
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress_repo.py         # ingestion_progress table access
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ xml_parser.py            # XML ‚Üí chunks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chunk_writer.py          # insert chunk (pg + weaviate)
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ rag/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models.py                # Chunk dataclass
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ router.py                # structured + semantic merge
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service.py               # RAGService.answer()
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ structured_search.py     # Postgres search
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ semantic_search.py       # Weaviate search
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chunk_merger.py           # dedupe + merge
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ context_resolver.py      # project/version detection
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ prompt_builder.py        # final prompt creation
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ retry.py                 # exponential backoff + jitter
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ metrics/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ retry_metrics.py         # retry stats
‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ db_schema/
‚îÇ       ‚îî‚îÄ‚îÄ schema.sql               # Postgres tables (policy_chunks, ingestion_progress)
‚îÇ
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ test_ingestion_resume.py
‚îÇ   ‚îú‚îÄ‚îÄ test_router.py
‚îÇ   ‚îî‚îÄ‚îÄ test_context_resolver.py
‚îÇ
‚îî‚îÄ‚îÄ data/
    ‚îî‚îÄ‚îÄ xml/
        ‚îú‚îÄ‚îÄ ProjectA/
        ‚îÇ   ‚îî‚îÄ‚îÄ policy_v1.xml
        ‚îî‚îÄ‚îÄ ProjectB/
            ‚îî‚îÄ‚îÄ policy_v3.xml



CREATE TABLE IF NOT EXISTS ingestion_progress (
    xml_path TEXT PRIMARY KEY,
    status TEXT NOT NULL CHECK (status IN ('PENDING','IN_PROGRESS','DONE','FAILED')),
    last_chunk_index INT NOT NULL DEFAULT -1,
    error TEXT,
    updated_at TIMESTAMP DEFAULT now()
);


import weaviate
import weaviate.classes as wvc
from weaviate.classes.config import (
    Configure,
    Property,
    DataType,
    Tokenization,
    VectorDistances,
)

CLASS_NAME = "AccessControlPolicy"


def create_access_control_policy_schema(client: weaviate.WeaviateClient):
    """
    Creates or verifies the Weaviate schema for AccessControlPolicy.
    Vectorizer is set to NONE (external embeddings).
    """

    # -------------------------------
    # Define properties
    # -------------------------------
    properties = [
        Property(
            name="project",
            data_type=DataType.TEXT,
            tokenization=Tokenization.FIELD,
            description="Project identifier"
        ),
        Property(
            name="mpu_name",
            data_type=DataType.TEXT,
            tokenization=Tokenization.FIELD,
            description="MPU name"
        ),
        Property(
            name="rg_index",
            data_type=DataType.INT,
            description="Region group index"
        ),
        Property(
            name="profile",
            data_type=DataType.TEXT,
            tokenization=Tokenization.FIELD,
            description="Access profile"
        ),
        Property(
            name="start",
            data_type=DataType.INT,
            description="Start address"
        ),
        Property(
            name="end",
            data_type=DataType.INT,
            description="End address"
        ),
        Property(
            name="chunk_index",
            data_type=DataType.INT,
            description="Chunk index"
        ),
        Property(
            name="chunk_text",
            data_type=DataType.TEXT,
            tokenization=Tokenization.WORD,
            description="Chunked text content"
        ),
    ]

    # -------------------------------
    # Check if collection exists
    # -------------------------------
    if client.collections.exists(CLASS_NAME):
        print(f"[schema] Collection '{CLASS_NAME}' already exists. Verifying...")

        collection = client.collections.get(CLASS_NAME)
        config = collection.config.get()

        existing_props = {p.name for p in config.properties}
        expected_props = {p.name for p in properties}

        missing = expected_props - existing_props
        if missing:
            print(f"[schema][WARN] Missing properties: {missing}")
        else:
            print(f"[schema] Existing schema is compatible")

        return

    # -------------------------------
    # Create collection
    # -------------------------------
    print(f"[schema] Creating collection '{CLASS_NAME}'")

    vectorizer_config = Configure.Vectorizer.none()

    vector_index_config = Configure.VectorIndex.hnsw(
        distance_metric=VectorDistances.COSINE
    )

    client.collections.create(
        name=CLASS_NAME,
        description="Vectorized MPU Region Access Control Policies",
        properties=properties,
        vectorizer_config=vectorizer_config,
        vector_index_config=vector_index_config,
        inverted_index_config=Configure.inverted_index(
            index_timestamps=True,
            index_property_length=True
        ),
    )

    print(f"[schema] Collection '{CLASS_NAME}' created successfully")





import weaviate
import os

WEAVIATE_URL = os.getenv("WEAVIATE_URL", "http://weaviate:8080")

_weaviate_client = None


def get_weaviate_client() -> weaviate.WeaviateClient:
    global _weaviate_client
    if _weaviate_client is None:
        _weaviate_client = weaviate.connect_to_custom(
            http_host="weaviate",
            http_port=8080,
            http_secure=False,
            grpc_host="weaviate",
            grpc_port=50051,
            grpc_secure=False,
        )
    return _weaviate_client






import weaviate
from weaviate.classes.config import (
    Configure,
    Property,
    DataType,
    Tokenization,
    VectorDistances,
)

CLASS_NAME = "AccessControlPolicy"


def ensure_schema(client: weaviate.WeaviateClient):
    if client.collections.exists(CLASS_NAME):
        print(f"[weaviate] Schema '{CLASS_NAME}' already exists")
        return

    print(f"[weaviate] Creating schema '{CLASS_NAME}'")

    client.collections.create(
        name=CLASS_NAME,
        description="Vectorized MPU Region Access Control Policies",
        vectorizer_config=Configure.Vectorizer.none(),
        vector_index_config=Configure.VectorIndex.hnsw(
            distance_metric=VectorDistances.COSINE
        ),
        properties=[
            Property("project", DataType.TEXT, tokenization=Tokenization.FIELD),
            Property("mpu_name", DataType.TEXT, tokenization=Tokenization.FIELD),
            Property("rg_index", DataType.INT),
            Property("profile", DataType.TEXT),
            Property("start", DataType.INT),
            Property("end", DataType.INT),
            Property("chunk_index", DataType.INT),
            Property("chunk_text", DataType.TEXT, tokenization=Tokenization.WORD),
        ],
    )

    print(f"[weaviate] Schema '{CLASS_NAME}' created")



from pydantic import BaseModel
from typing import List


class InsertObjectRequest(BaseModel):
    id: str
    vector: List[float]
    project: str
    mpu_name: str
    rg_index: int
    profile: str
    start: int
    end: int
    chunk_index: int
    chunk_text: str


class DeleteByIdRequest(BaseModel):
    id: str




from fastapi import FastAPI, HTTPException
from contextlib import asynccontextmanager

from app.weaviate_client import get_weaviate_client
from app.weaviate_schema import ensure_schema, CLASS_NAME
from app.models import InsertObjectRequest, DeleteByIdRequest


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    client = get_weaviate_client()
    ensure_schema(client)
    yield
    # Shutdown
    client.close()


app = FastAPI(lifespan=lifespan)


# -----------------------------
# Insert object
# -----------------------------
@app.post("/weaviate/insert")
def insert_object(req: InsertObjectRequest):
    client = get_weaviate_client()
    collection = client.collections.get(CLASS_NAME)

    try:
        collection.data.insert(
            uuid=req.id,
            vector=req.vector,
            properties={
                "project": req.project,
                "mpu_name": req.mpu_name,
                "rg_index": req.rg_index,
                "profile": req.profile,
                "start": req.start,
                "end": req.end,
                "chunk_index": req.chunk_index,
                "chunk_text": req.chunk_text,
            },
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

    return {"status": "inserted", "id": req.id}


# -----------------------------
# Delete object by ID
# -----------------------------
@app.delete("/weaviate/delete")
def delete_object(req: DeleteByIdRequest):
    client = get_weaviate_client()
    collection = client.collections.get(CLASS_NAME)

    try:
        collection.data.delete_by_id(req.id)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

    return {"status": "deleted", "id": req.id}















#!/bin/sh
set -e

WEAVIATE_URL="http://weaviate:8080"
CLASS_NAME="AccessControlPolicy"

echo "[schema-init] Waiting for Weaviate..."
until curl -sf "$WEAVIATE_URL/v1/.well-known/ready" >/dev/null; do
  sleep 2
done

echo "[schema-init] Checking if class exists: $CLASS_NAME"

if curl -sf "$WEAVIATE_URL/v1/schema/$CLASS_NAME" >/dev/null; then
  echo "[schema-init] Class '$CLASS_NAME' already exists. Skipping creation."
  exit 0
fi

echo "[schema-init] Creating class '$CLASS_NAME'"

curl -sf -X POST "$WEAVIATE_URL/v1/schema" \
  -H "Content-Type: application/json" \
  --data-binary @/schema/wv-schema.json

echo "[schema-init] Schema created successfully"




{
  "classes": [
    {
      "class": "AccessControlPolicy",
      "vectorizer": "none",
      "description": "Vectorized MPU Region Access Control Policies",
      "properties": [
        { "name": "project", "dataType": ["text"] },
        { "name": "mpu_name", "dataType": ["text"] },
        { "name": "rg_index", "dataType": ["int"] },
        { "name": "profile", "dataType": ["text"] },
        { "name": "start", "dataType": ["int"] },
        { "name": "end", "dataType": ["int"] },
        { "name": "chunk_index", "dataType": ["int"] },
        { "name": "chunk_text", "dataType": ["text"] }
      ]
    }
  ]
}

curl -X POST http://localhost:8000/query \
  -H "Content-Type: application/json" \
  -d '{"query":"What is the MPU access range?"}'


import pytest
from fastapi.testclient import TestClient
from app.api import app

client = TestClient(app)


def test_query_missing_context():
    response = client.post(
        "/query",
        json={"query": "What is the MPU access range?"}
    )

    assert response.status_code == 200
    data = response.json()

    assert "answer" in data
    assert data["needs_context"] is True
    assert "Project" in data["answer"]


def test_query_with_project_version(monkeypatch):
    # Mock RAGService.answer so API is isolated
    async def mock_answer(query: str):
        return "MOCK_FINAL_ANSWER"

    monkeypatch.setattr(
        "app.api.rag.answer",
        mock_answer
    )

    response = client.post(
        "/query",
        json={"query": "KAANAPALI version 5.3 MPU access range"}
    )

    assert response.status_code == 200
    data = response.json()

    assert data["needs_context"] is False
    assert data["answer"] == "MOCK_FINAL_ANSWER"



class RAGService:
    def __init__(self):
        self.session = None
        self.router = None
        self.db_conn = None
        self.db_cursor = None

    async def startup(self):
        """
        Called once when app starts
        """
        self.session = RAGSession()
        self.router = RAGRouter()

        # Example: DB connection
        self.db_conn, self.db_cursor = get_cursor()

    async def shutdown(self):
        """
        Called once when app stops
        """
        if self.db_cursor:
            self.db_cursor.close()

        if self.db_conn:
            self.db_conn.close()

        if hasattr(self.router, "close"):
            await self.router.close()

        print("üîª Resources released")






#!/usr/bin/env bash

API_URL="http://localhost:8000/query"

echo "üîç Test 1: Missing project context"
resp1=$(curl -s -X POST "$API_URL" \
  -H "Content-Type: application/json" \
  -d '{"query":"What is the MPU access range?"}')

echo "$resp1" | jq

echo "$resp1" | jq -e '.status=="clarification_required"' \
  && echo "‚úÖ PASS: clarification required" \
  || echo "‚ùå FAIL"

echo ""
echo "üîç Test 2: Providing project + version"
resp2=$(curl -s -X POST "$API_URL" \
  -H "Content-Type: application/json" \
  -d '{"query":"KAANAPALI version 5.3 MPU access range"}')

echo "$resp2" | jq

echo "$resp2" | jq -e '.status=="success"' \
  && echo "‚úÖ PASS: answered with context" \
  || echo "‚ùå FAIL"




#!/usr/bin/env bash

API_URL="http://localhost:8000/query"

echo "üîç Test 1: Missing project context"
curl -s -X POST "$API_URL" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "What is the MPU access range?"
  }' | jq

echo ""
echo "üîç Test 2: Providing project + version"
curl -s -X POST "$API_URL" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "KAANAPALI version 5.3 MPU access range"
  }' | jq






from fastapi import FastAPI
from pydantic import BaseModel
from app.rag.service import RAGService

app = FastAPI()
rag = RAGService()

class QueryRequest(BaseModel):
    query: str

class QueryResponse(BaseModel):
    answer: str
    needs_context: bool | None = None

@app.post("/query", response_model=QueryResponse)
async def query_rag(req: QueryRequest):
    result = rag.answer(req.query)
    return result




[build-system]
requires = ["setuptools>=68.0"]
build-backend = "setuptools.build_meta"

[project]
name = "xbot-access-ctrl"
version = "0.1.0"
description = "RAG system for XML-based access control policies"
requires-python = ">=3.10"

dependencies = [
  "fastapi",
  "uvicorn",
  "psycopg2-binary",
  "weaviate-client",
  "lxml",
  "pydantic",
  "requests",
  "pytest"
]

[tool.setuptools]
packages = ["app"]

[tool.pytest.ini_options]
pythonpath = ["."]
testpaths = ["app/tests"]







class RAGRouter:

    async def retrieve_async(self, query: str, filters: dict):
        qtype = classify_query(query)

        if qtype == QueryType.STRUCTURED:
            return self.structured_search(filters)

        elif qtype == QueryType.SEMANTIC:
            return self.semantic_search(query, filters)

        else:
            structured = self.structured_search(filters)
            semantic = self.semantic_search(query, filters)
            return structured[:4] + semantic[:4]

import os
import requests

class WeaviateClient:
    def __init__(self):
        self.url = os.getenv("WEAVIATE_URL")
        self.class_name = os.getenv("WEAVIATE_CLASS")

    def insert_vector(self, vector, meta, vid):
        payload = {
            "class": self.class_name,
            "id": vid,
            "properties": meta,
            "vector": vector,
        }
        r = requests.post(f"{self.url}/v1/objects", json=payload)
        r.raise_for_status()

    def semantic_search(self, vector, limit=5, where=None):
        query = {
            "query": """
            query ($vector: [Float!]) {
              Get {
                %s(
                  nearVector: {vector: $vector}
                  limit: %d
                ) {
                  identity_hash
                  chunk_index
                  project
                  profile
                }
              }
            }
            """ % (self.class_name, limit),
            "variables": {"vector": vector},
        }
        r = requests.post(f"{self.url}/v1/graphql", json=query)
        r.raise_for_status()
        return r.json()


def extract_project_from_fqname(fqname: str) -> str:
    if not fqname or "." not in fqname:
        raise RuntimeError(f"Invalid fqname, cannot extract project: {fqname}")
    return fqname.split(".", 1)[0].strip()




-- ================================
-- Core Table: policy_chunks
-- ================================

CREATE TABLE IF NOT EXISTS policy_chunks (
    id BIGSERIAL PRIMARY KEY,

    -- Canonical Policy Identity
    project        TEXT NOT NULL,
    mpu_name       TEXT NOT NULL,
    rg_index       INTEGER NOT NULL,
    profile        TEXT NOT NULL DEFAULT 'TZ',

    -- Address Range
    start_dec      BIGINT NOT NULL,
    end_dec        BIGINT NOT NULL,
    start_hex      TEXT,
    end_hex        TEXT,

    -- Versioning & Hashing
    policy_version TEXT NOT NULL,
    identity_hash  TEXT NOT NULL,
    content_hash   TEXT NOT NULL,

    -- Chunking
    chunk_index    INTEGER NOT NULL,
    chunk_text     TEXT NOT NULL,

    -- Vector Mapping
    vector_id      TEXT NOT NULL,
    vector_db      TEXT DEFAULT 'weaviate',

    -- Lifecycle
    is_active      BOOLEAN NOT NULL DEFAULT TRUE,
    is_propagated  BOOLEAN DEFAULT FALSE,

    -- Traceability
    xml_path       TEXT,
    parent_project TEXT,

    -- Audit
    created_at     TIMESTAMPTZ DEFAULT now(),
    updated_at     TIMESTAMPTZ DEFAULT now()
);

-- ================================
-- CRITICAL CONSTRAINTS
-- ================================

-- Prevent duplicate chunks for same logical policy
CREATE UNIQUE INDEX IF NOT EXISTS uq_identity_chunk
ON policy_chunks(identity_hash, chunk_index);

-- Guarantee only ONE ACTIVE version of a policy
CREATE UNIQUE INDEX IF NOT EXISTS uq_active_identity
ON policy_chunks(identity_hash)
WHERE is_active = TRUE;

-- ================================
-- PERFORMANCE INDEXES
-- ================================

CREATE INDEX IF NOT EXISTS idx_project
ON policy_chunks(project);

CREATE INDEX IF NOT EXISTS idx_project_active
ON policy_chunks(project, is_active);

CREATE INDEX IF NOT EXISTS idx_mpu_rg_profile
ON policy_chunks(mpu_name, rg_index, profile);

CREATE INDEX IF NOT EXISTS idx_range
ON policy_chunks(start_dec, end_dec);

CREATE INDEX IF NOT EXISTS idx_profile_active
ON policy_chunks(profile)
WHERE is_active = TRUE;

CREATE INDEX IF NOT EXISTS idx_content_hash
ON policy_chunks(content_hash);

-- ================================
-- PROJECT HIERARCHY (Propagation)
-- ================================

CREATE TABLE IF NOT EXISTS project_hierarchy (
    parent_project TEXT NOT NULL,
    child_project  TEXT NOT NULL,
    created_at     TIMESTAMPTZ DEFAULT now(),
    PRIMARY KEY (parent_project, child_project)
);

-- ================================
-- INGESTION LOCK (Race Prevention)
-- ================================

CREATE TABLE IF NOT EXISTS ingestion_lock (
    project TEXT PRIMARY KEY,
    locked_at TIMESTAMPTZ DEFAULT now()
);



services:

  weaviate:
    image: semitechnologies/weaviate:1.25.2
    container_name: rag-weaviate
    restart: always
    environment:
      QUERY_DEFAULTS_LIMIT: 25
      AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED: "true"
      PERSISTENCE_DATA_PATH: "/var/lib/weaviate"
      ENABLE_MODULES: "text2vec-transformers"
      DEFAULT_VECTORIZER_MODULE: "text2vec-transformers"
      TRANSFORMERS_INFERENCE_API: "http://transformers:8080"
    ports:
      - "8080:8080"
    depends_on:
      - transformers
    volumes:
      - rag_weaviate:/var/lib/weaviate

  weaviate-schema-init:
    image: curlimages/curl:8.5.0
    container_name: rag-weaviate-schema-init
    depends_on:
      - weaviate
    restart: "no"
    entrypoint: ["/bin/sh", "-c"]
    command: >
      echo "Waiting for Weaviate..." &&
      until curl -s http://weaviate:8080/v1/.well-known/ready; do
        sleep 2;
      done &&
      echo "Creating AccessControlPolicy schema..." &&
      curl -s -X POST http://weaviate:8080/v1/schema
      -H "Content-Type: application/json"
      -d '{
        "class": "AccessControlPolicy",
        "vectorizer": "text2vec-transformers",
        "description": "Vectorized MPU Region Access Control Policies",
        "properties": [
          { "name": "project",  "dataType": ["text"] },
          { "name": "mpu_name", "dataType": ["text"] },
          { "name": "rg_index", "dataType": ["int"] },
          { "name": "profile",  "dataType": ["text"] },
          { "name": "version",  "dataType": ["text"] },
          { "name": "start",    "dataType": ["int"] },
          { "name": "end",      "dataType": ["int"] },
          { "name": "chunk_index", "dataType": ["int"] },
          { "name": "chunk_text",  "dataType": ["text"] }
        ]
      }' ||
      echo "Schema already exists, skipping..."




Profile normalisation ("" ‚Üí "TZ")

Add this helper near the top:
def normalize_profile(raw: str | None) -> str:
    """
    Canonical profile rules:
    - None or ""  => "TZ"
    - strip spaces otherwise
    """
    if raw is None:
        return "TZ"
    raw = raw.strip()
    return raw if raw else "TZ"

Update parse_prtn
"profile": normalize_profile(node.get("profile")),

Now:
	‚Ä¢	profile="" ‚Üí "TZ"
	‚Ä¢	profile=None ‚Üí "TZ"
	‚Ä¢	MSA / TME_FW / TME_ROM stay as-is

from lxml import etree

def canonical_xml(xml_str: str) -> str:
    """
    Canonicalize XML to avoid whitespace / attribute order noise.
    """
    root = etree.fromstring(xml_str.encode())
    return etree.tostring(root, method="c14n").decode()

canonical = canonical_xml(prtn["raw_xml"])
xml_hash = sha256(canonical)

import re

def bump_version(prev: str | None) -> str:
    """
    Very simple version bumper.
    - If prev is None          -> "v1.0"
    - If prev=="v1.0"          -> "v1.1"
    - If prev=="v2.3"          -> "v2.4"
    - If format unknown        -> prev + "+1"
    """
    if prev is None:
        return "v1.0"

    m = re.match(r"^v?(\d+)\.(\d+)$", prev)
    if not m:
        return prev + "+1"

    major, minor = int(m.group(1)), int(m.group(2))
    return f"v{major}.{minor+1}"

Replace ingest_prtn with auto-version logic

Here is a complete version of ingest_prtn that:
	‚Ä¢	Normalises profile (already done in parse_prtn)
	‚Ä¢	Looks up latest version for (project, mpu, RG, profile)
	‚Ä¢	Skips if same hash
	‚Ä¢	Otherwise auto-bumps version and inserts new row
	‚Ä¢	Deactivates previous active row(s)
	‚Ä¢	Prints a diff between old and new

def ingest_prtn(project: str, mpu_name: str, prtn: dict):

    rg_index = prtn["rg_index"]
    profile  = prtn["profile"]          # already normalized
    raw_xml  = prtn["raw_xml"]

    canonical = canonical_xml(raw_xml)
    xml_hash  = sha256(canonical)

    info(f"      [RG {rg_index}] profile={profile} start={prtn['start_hex']} end={prtn['end_hex']}")

    # 1Ô∏è‚É£ Look up latest version for this (project, mpu, RG, profile)
    latest = pg_fetch_one(
        """
        SELECT chunk_id, xml_hash, policy_version, is_active,
               start_hex, end_hex, rdomains, wdomains, rvmids, wvmids,
               static, confirmed, enabled
        FROM policy_chunks
        WHERE project=%s
          AND branch='main'
          AND mpu_name=%s
          AND rg_index=%s
          AND profile=%s
        ORDER BY created_at DESC
        LIMIT 1
        """,
        (project, mpu_name, rg_index, profile)
    )

    # 2Ô∏è‚É£ No previous version ‚Üí first insert
    if not latest:
        new_ver = bump_version(None)
        info(f"      ‚úÖ INSERT RG {rg_index} / {profile} (first seen, ver={new_ver})")

        new_chunk_id = str(uuid.uuid4())
        insert_new_policy(
            project, mpu_name, prtn,
            xml_hash, new_chunk_id,
            policy_version=new_ver,
            supersedes=None
        )
        return

    # There *is* a previous version
    (old_chunk_id, old_hash, old_ver, old_active,
     old_start_hex, old_end_hex, old_rdomains, old_wdomains,
     old_rvmids, old_wvmids, old_static, old_confirmed,
     old_enabled) = latest

    if old_hash == xml_hash:
        # Same content as last version ‚Üí skip
        info(f"      ‚è≠Ô∏è SKIP RG {rg_index} / {profile} (same content, ver={old_ver})")
        return

    # 3Ô∏è‚É£ Content changed ‚Üí auto bump version
    new_ver = bump_version(old_ver)
    warn(f"      ‚ôªÔ∏è CHANGE DETECTED RG {rg_index} / {profile}: {old_ver} ‚Üí {new_ver}")

    # 3aÔ∏è‚É£ emit diff
    diffs = []

    def add_diff(field, old, new):
        if old != new:
            diffs.append(f"        - {field}: {old} ‚Üí {new}")

    add_diff("start_hex", old_start_hex, prtn["start_hex"])
    add_diff("end_hex",   old_end_hex,   prtn["end_hex"])
    add_diff("rdomains",  old_rdomains,  prtn["rdomains"])
    add_diff("wdomains",  old_wdomains,  prtn["wdomains"])
    add_diff("rvmids",    old_rvmids,    prtn["rvmids"])
    add_diff("wvmids",    old_wvmids,    prtn["wvmids"])
    add_diff("static",    old_static,    False)          # you currently fix static=False
    add_diff("confirmed", old_confirmed, prtn["confirmed"])
    add_diff("enabled",   old_enabled,   True)           # you currently fix enabled=True

    if diffs:
        warn("      üîç Diff vs previous:")
        for line in diffs:
            warn(line)

    # 3bÔ∏è‚É£ deactivate any active rows for this (RG, profile)
    pg_execute(
        """
        UPDATE policy_chunks
        SET is_active=false
        WHERE project=%s AND mpu_name=%s AND rg_index=%s AND profile=%s
          AND is_active=true
        """,
        (project, mpu_name, rg_index, profile)
    )

    delete_weaviate_vector(old_chunk_id)

    # 3cÔ∏è‚É£ insert new version, linked via supersedes_chunk_id
    new_chunk_id = str(uuid.uuid4())
    insert_new_policy(
        project, mpu_name, prtn,
        xml_hash, new_chunk_id,
        policy_version=new_ver,
        supersedes=old_chunk_id
    )

    info(f"      ‚úÖ INSERT RG {rg_index} / {profile} (new ver={new_ver})")

Update insert_new_policy signature

Change it to accept an explicit policy_version:

def insert_new_policy(
    project: str,
    mpu_name: str,
    prtn: dict,
    xml_hash: str,
    chunk_id: str,
    policy_version: str,
    supersedes: str | None = None
):
    start_dec = hex_to_dec(prtn["start_hex"])
    end_dec   = hex_to_dec(prtn["end_hex"])

    pg_execute(
        """
        INSERT INTO policy_chunks (
            chunk_id, project, branch, file_path, policy_version,
            mpu_name, rg_index, profile,
            start_dec, end_dec, start_hex, end_hex,
            rdomains, wdomains, rvmids, wvmids,
            static, confirmed, enabled,
            raw_xml, xml_hash,
            is_active, supersedes_chunk_id,
            weaviate_object_id
        )
        VALUES (%s,%s,'main',%s,%s,
                %s,%s,%s,
                %s,%s,%s,%s,
                %s,%s,%s,%s,
                %s,%s,%s,
                %s,%s,
                true,%s,
                %s)
        """,
        (
            chunk_id,
            project,
            prtn.get("file_path"),   # or None
            policy_version,
            mpu_name,
            prtn["rg_index"],
            prtn["profile"],
            start_dec,
            end_dec,
            prtn["start_hex"],
            prtn["end_hex"],
            prtn["rdomains"],
            prtn["wdomains"],
            prtn["rvmids"],
            prtn["wvmids"],
            False,                   # static
            prtn["confirmed"],
            True,                    # enabled
            prtn["raw_xml"],
            xml_hash,
            supersedes,
            chunk_id,
        )
    )

    # build chunk_text & insert into Weaviate as before ‚Ä¶

def insert_new_policy(
    project: str,
    mpu_name: str,
    prtn: dict,
    xml_hash: str,
    chunk_id: str,
    policy_version: str,
    supersedes: str | None = None
):
    start_dec = hex_to_dec(prtn["start_hex"])
    end_dec   = hex_to_dec(prtn["end_hex"])

    pg_execute(
        """
        INSERT INTO policy_chunks (
            chunk_id, project, branch, file_path, policy_version,
            mpu_name, rg_index, profile,
            start_dec, end_dec, start_hex, end_hex,
            rdomains, wdomains, rvmids, wvmids,
            static, confirmed, enabled,
            raw_xml, xml_hash,
            is_active, supersedes_chunk_id,
            weaviate_object_id
        )
        VALUES (%s,%s,'main',%s,%s,
                %s,%s,%s,
                %s,%s,%s,%s,
                %s,%s,%s,%s,
                %s,%s,%s,
                %s,%s,
                true,%s,
                %s)
        """,
        (
            chunk_id,
            project,
            prtn.get("file_path"),   # or None
            policy_version,
            mpu_name,
            prtn["rg_index"],
            prtn["profile"],
            start_dec,
            end_dec,
            prtn["start_hex"],
            prtn["end_hex"],
            prtn["rdomains"],
            prtn["wdomains"],
            prtn["rvmids"],
            prtn["wvmids"],
            False,                   # static
            prtn["confirmed"],
            True,                    # enabled
            prtn["raw_xml"],
            xml_hash,
            supersedes,
            chunk_id,
        )
    )

In rag_api.py:

class PropagateRequest(BaseModel):
    parent_project: str
    child_project: str
    mpu_name: Optional[str] = None
    profile: Optional[str] = None   # NEW

Normalize profile in handler:

from typing import Optional

def normalize_profile_query(p: Optional[str]) -> Optional[str]:
    if p is None:
        return None
    p = p.strip()
    return "TZ" if p == "" else p

propagate 
@app.post("/propagate")
def propagate_policies(req: PropagateRequest):
    profile = normalize_profile_query(req.profile)

    parent_rows = pg_get_active_policies(req.parent_project, req.mpu_name, profile)
    child_rows  = pg_get_active_policies(req.child_project,  req.mpu_name, profile)
    ...

def pg_get_active_policies(project: str, mpu_name: Optional[str] = None, profile: Optional[str] = None):
    sql = """
    SELECT *
    FROM policy_chunks
    WHERE project = %s
      AND is_active = true
      AND (%s IS NULL OR mpu_name = %s)
      AND (%s IS NULL OR profile = %s)
    ORDER BY mpu_name, rg_index, profile;
    """
    params = (project, mpu_name, mpu_name, profile, profile)
    return pg_fetch_rows(sql, params)






curl -X DELETE http://localhost:8080/v1/schema/AccessControlPolicy

curl http://localhost:8080/v1/schema -H "Content-Type: application/json" -d '{
  "class": "AccessControlPolicy",
  "vectorizer": "text2vec-transformers",
  "properties": [
    { "name": "chunk_text", "dataType": ["text"] },
    { "name": "project", "dataType": ["text"] },
    { "name": "mpu_name", "dataType": ["text"] },
    { "name": "rg_index", "dataType": ["int"] },
    { "name": "profile", "dataType": ["text"] }
  ]
}'





logging 

# -----------------------------
# DEBUG CONFIG
# -----------------------------

DEBUG_MODE = os.getenv("INGEST_DEBUG", "false").lower() == "true"
DEBUG_SQL  = os.getenv("INGEST_DEBUG_SQL", "false").lower() == "true"

logging.basicConfig(
    level=logging.DEBUG if DEBUG_MODE else logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)]
)

log = logging.getLogger("INGEST")


def dbg(msg: str):
    if DEBUG_MODE:
        log.debug(msg)

def info(msg: str):
    log.info(msg)

def warn(msg: str):
    log.warning(msg)

def err(msg: str):
    log.error(msg)

def ingest_project(project_dir: str):
    project = os.path.basename(project_dir)

    info(f"[PROJECT] {project}")

    for xml_file in glob.glob(os.path.join(project_dir, "*.xml")):
        info(f"  ‚Üí Parsing {xml_file}")

        tree = etree.parse(xml_file)
        root = tree.getroot()

        for mpu_node in root.findall(".//MPU"):
            mpu_name = mpu_node.get("name")

            if not mpu_name:
                err("MPU node found without name attribute")
                raise RuntimeError("MPU node found without name attribute")

            info(f"    [MPU] {mpu_name}")

            for prtn_node in mpu_node.findall(".//PRTn"):
                prtn = parse_prtn(prtn_node)

                dbg(
                    f"      [RG {prtn['rg_index']}] "
                    f"profile={prtn['profile']} "
                    f"start={prtn['start_hex']} end={prtn['end_hex']}"
                )

                ingest_prtn(project, mpu_name, prtn)

def ingest_prtn(project: str, mpu_name: str, prtn: Dict[str, Any]):

    rg_index = prtn["rg_index"]
    profile  = prtn["profile"]
    raw_xml  = prtn["raw_xml"]
    xml_hash = sha256(raw_xml)

    dbg(f"[CHECK] {project}/{mpu_name}/RG{rg_index}/{profile}")

    # -----------------------------
    # 1Ô∏è‚É£ SAME VERSION GUARD
    # -----------------------------

    same_version = pg_fetch_one(
        """
        SELECT chunk_id, xml_hash, is_active
        FROM policy_chunks
        WHERE project=%s
          AND branch='main'
          AND mpu_name=%s
          AND rg_index=%s
          AND COALESCE(profile,'')=COALESCE(%s,'')
          AND policy_version=%s
        """,
        (project, mpu_name, rg_index, profile, POLICY_VERSION)
    )

    if same_version:
        chunk_id, old_hash, is_active = same_version

        dbg(
            f"[FOUND-SAME-VERSION] RG{rg_index} "
            f"hash_db={old_hash[:12]} hash_xml={xml_hash[:12]} "
            f"active={is_active}"
        )

        if old_hash == xml_hash:
            info(f"      ‚è≠Ô∏è SKIP RG {rg_index} (same version, unchanged)")
            return

        # Illegal mutation
        err(
            f"üî• ILLEGAL CHANGE: {project}/{mpu_name}/RG{rg_index}/{profile} "
            f"modified without version bump"
        )
        raise RuntimeError(
            f"Policy modified without version bump: "
            f"{project}/{mpu_name}/RG{rg_index}/{profile}"
        )

    # -----------------------------
    # 2Ô∏è‚É£ FIND CURRENT ACTIVE POLICY
    # -----------------------------

    active_row = pg_fetch_one(
        """
        SELECT chunk_id, xml_hash
        FROM policy_chunks
        WHERE project=%s
          AND mpu_name=%s
          AND rg_index=%s
          AND COALESCE(profile,'')=COALESCE(%s,'')
          AND is_active=true
        """,
        (project, mpu_name, rg_index, profile)
    )

    if active_row:
        old_chunk_id, old_hash = active_row

        dbg(
            f"[ACTIVE-FOUND] RG{rg_index} "
            f"old_chunk={old_chunk_id}"
        )

        info(f"      ‚ôªÔ∏è UPDATE RG {rg_index}")

        # Deactivate previous
        pg_execute(
            "UPDATE policy_chunks SET is_active=false WHERE chunk_id=%s",
            (old_chunk_id,)
        )

        delete_weaviate_vector(old_chunk_id)

        new_chunk_id = str(uuid.uuid4())
        insert_new_policy(
            project, mpu_name, prtn,
            xml_hash, new_chunk_id,
            supersedes=old_chunk_id
        )

        info(f"      ‚úÖ Inserted new RG {rg_index} (ACTIVE)")
        return

    # -----------------------------
    # 3Ô∏è‚É£ FIRST INSERT
    # -----------------------------

    info(f"      ‚úÖ INSERT RG {rg_index} (first seen)")

    new_chunk_id = str(uuid.uuid4())
    insert_new_policy(
        project, mpu_name, prtn,
        xml_hash, new_chunk_id
    )

def pg_execute(query: str, params: tuple):
    if DEBUG_SQL:
        dbg(f"[SQL] {query.strip()} | params={params}")
    cur = pg.cursor()
    cur.execute(query, params)

def pg_fetch_one(query: str, params: tuple):
    if DEBUG_SQL:
        dbg(f"[SQL] {query.strip()} | params={params}")
    cur = pg.cursor()
    cur.execute(query, params)
    return cur.fetchone()









CREATE TABLE policy_chunks (

    chunk_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

    project TEXT NOT NULL,
    branch  TEXT DEFAULT 'main',
    file_path TEXT,
    file_version TEXT,
    policy_version TEXT NOT NULL,
    xml_path TEXT,

    mpu_name TEXT NOT NULL,
    rg_index INT  NOT NULL,
    profile  TEXT,

    policy_id    TEXT,
    policy_title TEXT,

    start_dec BIGINT,
    end_dec   BIGINT,
    start_hex TEXT,
    end_hex   TEXT,

    rdomains TEXT[],
    wdomains TEXT[],
    rvmids   TEXT[],
    wvmids   TEXT[],

    static    BOOLEAN,
    confirmed BOOLEAN,
    enabled   BOOLEAN,

    raw_xml  TEXT NOT NULL,
    xml_hash TEXT NOT NULL,

    is_active BOOLEAN NOT NULL DEFAULT true,
    supersedes_chunk_id UUID NULL,

    weaviate_object_id UUID UNIQUE NOT NULL,

    created_at TIMESTAMP DEFAULT NOW(),

    UNIQUE (project, branch, mpu_name, rg_index, profile, policy_version)
);

CREATE INDEX idx_active_policy
ON policy_chunks(project, branch, mpu_name, rg_index, profile)
WHERE is_active = true;

CREATE INDEX idx_project_mpu
ON policy_chunks(project, mpu_name);

CREATE INDEX idx_addr_range
ON policy_chunks(start_dec, end_dec);

CREATE INDEX idx_weaviate_id
ON policy_chunks(weaviate_object_id);

CREATE INDEX idx_xml_hash
ON policy_chunks(xml_hash);












export PG_HOST=localhost
export PG_DB=ragdb
export PG_USER=raguser
export PG_PASSWORD=ragpass
export WEAVIATE_URL=http://localhost:8080
export POLICY_VERSION=v1.0    # change per ingestion


class PropagateRequest(BaseModel):
    parent_project: str
    child_project: str
    mpu_name: Optional[str] = None   # null = all MPUs


def pg_get_active_policies(project: str, mpu_name: Optional[str] = None):
    sql = """
    SELECT *
    FROM policy_chunks
    WHERE project = %s
      AND is_active = true
      AND (%s IS NULL OR mpu_name = %s)
    ORDER BY mpu_name, rg_index, profile;
    """

    params = (project, mpu_name, mpu_name)
    return pg_fetch_rows(sql, params)


def logical_key(row: Dict[str, Any]):
    """
    Logical policy identity for propagation & diff.
    """
    return (row["mpu_name"], row["rg_index"], row.get("profile"))


@app.post("/propagate")
def propagate_policies(req: PropagateRequest):
    """
    Parent ‚Üí Child policy propagation planner.

    Returns:
      - propagate_missing : policies present in parent but missing in child
      - propagate_review  : policies present in both but with different rules
    """

    parent_rows = pg_get_active_policies(req.parent_project, req.mpu_name)
    child_rows  = pg_get_active_policies(req.child_project,  req.mpu_name)

    parent_map = {logical_key(r): r for r in parent_rows}
    child_map  = {logical_key(r): r for r in child_rows}

    propagate_missing = []
    propagate_review  = []

    compare_fields = [
        "start_dec",
        "end_dec",
        "rdomains",
        "wdomains",
        "rvmids",
        "wvmids",
        "static",
        "confirmed",
        "enabled",
    ]

    for key, parent_row in parent_map.items():
        child_row = child_map.get(key)

        # -----------------------------
        # Case 1: Missing in Child ‚Üí MUST PROPAGATE
        # -----------------------------
        if not child_row:
            propagate_missing.append(
                {
                    "mpu_name": parent_row["mpu_name"],
                    "rg_index": parent_row["rg_index"],
                    "profile": parent_row.get("profile"),
                    "parent_policy": parent_row,
                }
            )
            continue

        # -----------------------------
        # Case 2: Exists in both ‚Üí CHECK FOR DIFFERENCES
        # -----------------------------
        diffs = {}
        for f in compare_fields:
            if parent_row[f] != child_row[f]:
                diffs[f] = {
                    req.parent_project: parent_row[f],
                    req.child_project:  child_row[f],
                }

        if diffs:
            propagate_review.append(
                {
                    "mpu_name": parent_row["mpu_name"],
                    "rg_index": parent_row["rg_index"],
                    "profile": parent_row.get("profile"),
                    "diffs": diffs,
                    "parent_policy": parent_row,
                    "child_policy": child_row,
                }
            )

    return {
        "parent_project": req.parent_project,
        "child_project": req.child_project,
        "mpu_name": req.mpu_name,
        "propagate_missing": propagate_missing,
        "propagate_review": propagate_review,
        "summary": {
            "missing_count": len(propagate_missing),
            "review_count": len(propagate_review),
        },
    }

