from typing import Optional, Sequence
from llama_index.core.llms import LLM
from llama_index.core.llms.callbacks import llm_completion_callback
from llama_index.core.llms.types import CompletionResponse, LLMMetadata


class QGenieLLM(LLM):
    def __init__(self, client, model: str):
        self._client = client
        self._model = model

    @property
    def metadata(self) -> LLMMetadata:
        return LLMMetadata(
            model_name=self._model,
            context_window=8192,
            num_output=512,
            is_chat_model=True,
        )

    @llm_completion_callback()
    def complete(self, prompt: str, **kwargs) -> CompletionResponse:
        resp = self._client.complete(
            prompt=prompt,
            model=self._model,
        )
        return CompletionResponse(text=resp)

    @llm_completion_callback()
    def stream_complete(self, prompt: str, **kwargs):
        for chunk in self._client.stream(prompt, model=self._model):
            yield CompletionResponse(text=chunk)






from typing import Dict, List, Any
import logging

from llama_index.core.schema import NodeWithScore
from llama_index.core.response_synthesizers import ResponseSynthesizer
from llama_index.core import PromptTemplate

from rag.planner import Planner
from rag.executors import SQLExecutors
from rag.nodes import (
    ScalarNodeAdapter,
    EntityListNodeAdapter,
    IntervalPolicyNodeAdapter,
)
from rag.hyde import HydeGenerator
from rag.instructor import InstructorClient
from rag.models import QueryFacts

logger = logging.getLogger(__name__)


class RagOrchestrator:
    """
    Central control flow for TAG queries.
    """

    def __init__(
        self,
        db,
        llm,
        hyde: HydeGenerator,
        instructor: InstructorClient,
        planner: Planner,
        executors: SQLExecutors,
    ):
        self.db = db
        self.llm = llm
        self.hyde = hyde
        self.instructor = instructor
        self.planner = planner
        self.executors = executors

        # üîí Adapter registry (frozen)
        self.node_adapters = {
            "policy_by_address": IntervalPolicyNodeAdapter(),
            "policy_list": EntityListNodeAdapter(),
            "project_list": EntityListNodeAdapter(),
            "project_count": ScalarNodeAdapter(),
            "mpu_count": ScalarNodeAdapter(),
        }

        self.response_synthesizer = self._build_synthesizer()

    # -------------------------------------------------
    # Public entrypoint
    # -------------------------------------------------
    def run(self, user_query: str) -> Dict[str, Any]:
        logger.info("RAG Orchestrator invoked")

        # 1Ô∏è‚É£ HYDE
        hyde_text = self.hyde.generate(user_query)

        # 2Ô∏è‚É£ Instructor ‚Üí QueryFacts
        facts: QueryFacts = self.instructor.extract(user_query, hyde_text)

        # 3Ô∏è‚É£ Planner ‚Üí ExecutionPlan
        plan = self.planner.build(facts)

        # 4Ô∏è‚É£ Execute plan
        raw_result = self._execute(plan)

        # 5Ô∏è‚É£ Convert to Nodes
        nodes = self._to_nodes(plan.executor, raw_result)

        # 6Ô∏è‚É£ Synthesize response
        response = self.response_synthesizer.synthesize(
            query=user_query,
            nodes=nodes,
        )

        return {
            "answer": str(response),
            "confidence": self._confidence(nodes),
            "sources": self._sources(nodes),
        }

    # -------------------------------------------------
    # Execution
    # -------------------------------------------------
    def _execute(self, plan):
        logger.debug(f"Executing plan: {plan.executor}")
        executor_fn = getattr(self.executors, plan.executor)
        return executor_fn(plan.params)

    # -------------------------------------------------
    # Node conversion
    # -------------------------------------------------
    def _to_nodes(self, executor_name: str, rows: Any) -> List[NodeWithScore]:
        adapter = self.node_adapters.get(executor_name)
        if not adapter:
            raise RuntimeError(f"No NodeAdapter registered for {executor_name}")

        return adapter.to_nodes(rows)

    # -------------------------------------------------
    # Synthesizer
    # -------------------------------------------------
    def _build_synthesizer(self) -> ResponseSynthesizer:
        system_prompt = PromptTemplate(
            """
You are a policy analysis assistant.

Rules:
- Use only provided context.
- If multiple regions conflict, explain why.
- If no data exists, say so explicitly.
- Do not hallucinate.
"""
        )

        return ResponseSynthesizer.from_args(
            llm=self.llm,
            system_prompt=system_prompt,
            response_mode="compact",
        )

    # -------------------------------------------------
    # Confidence + sources
    # -------------------------------------------------
    def _confidence(self, nodes: List[NodeWithScore]) -> float:
        if not nodes:
            return 0.0
        return min(1.0, sum(n.score or 0.3 for n in nodes) / len(nodes))

    def _sources(self, nodes: List[NodeWithScore]) -> List[dict]:
        return [n.node.metadata for n in nodes]










class ScalarNodeAdapter:
    @staticmethod
    def to_nodes(result: dict, *, entity: str, metric: str):
        return [
            TextNode(
                text="",
                metadata={
                    "type": "catalog",
                    "entity": entity,
                    "metric": metric,     # "count"
                    "value": result[metric],
                    "confidence": result.get("confidence", 1.0),
                    "explain": result.get("explanation", ""),
                }
            )
        ]

class EntityListNodeAdapter:
    @staticmethod
    def to_nodes(result: dict, *, entity: str):
        nodes = []

        for row in result.get("rows", []):
            nodes.append(
                TextNode(
                    text="",
                    metadata={
                        "type": "catalog",
                        "entity": entity,
                        **row,
                        "confidence": result.get("confidence", 1.0),
                        "explain": "entity metadata",
                    }
                )
            )
        return nodes

class IntervalPolicyNodeAdapter:
    @staticmethod
    def to_nodes(result: dict):
        nodes = []

        for row in result.get("rows", []):
            nodes.append(
                TextNode(
                    text="",
                    metadata={
                        "type": "policy",
                        "entity": "POLICY",
                        "mpu": row["mpu_name"],
                        "addr_start": row["addr_start"],
                        "addr_end": row["addr_end"],
                        "profile": row["profile"],
                        "confidence": row["confidence"],
                        "explain": row["explain"],
                    }
                )
            )
        return nodes










class PolicyByAddressExecutor:
    def __init__(self, db):
        self.db = db

    def run(self, facts) -> list[dict]:
        rows = self.db.fetch_all(
            """
            SELECT mpu_name, addr_start, addr_end, profile
            FROM xml_chunks
            WHERE project = %s
              AND addr_start <= %s
              AND addr_end >= %s
            ORDER BY (addr_end - addr_start) ASC
            LIMIT 1
            """,
            (facts.project, facts.address, facts.address),
        )

        results = []
        for r in rows:
            results.append({
                "text": (
                    f"Address 0x{facts.address:X} is covered by MPU "
                    f"{r['mpu_name']} range "
                    f"[0x{r['addr_start']:X} - 0x{r['addr_end']:X}] "
                    f"with profile {r['profile']}."
                ),
                "metadata": {
                    "entity": "policy",
                    "mpu": r["mpu_name"],
                    "confidence": 0.95,
                    "explain": "smallest matching MPU region",
                }
            })

        return results





from pydantic import field_validator

class QueryFacts(BaseModel):
    intent: Optional[Intent] = None
    operation: Optional[Operation] = None
    entity: Optional[list[Entity]] = None

    @field_validator("intent", mode="before")
    @classmethod
    def coerce_intent(cls, v):
        if v is None:
            return v
        if isinstance(v, Intent):
            return v
        if isinstance(v, str):
            return Intent[v]
        raise TypeError(f"Invalid intent value: {v}")

    @field_validator("operation", mode="before")
    @classmethod
    def coerce_operation(cls, v):
        if v is None:
            return v
        if isinstance(v, Operation):
            return v
        if isinstance(v, str):
            return Operation[v]
        raise TypeError(f"Invalid operation value: {v}")

    @field_validator("entity", mode="before")
    @classmethod
    def coerce_entity(cls, v):
        if v is None:
            return v
        if isinstance(v, list):
            return [
                e if isinstance(e, Entity) else Entity[e]
                for e in v
            ]
        raise TypeError(f"Invalid entity value: {v}")




def _build_llm_context_jinja(
    self,
    user_query: str,
    hyde_text: str,
    execution_result: Dict,
    facts: QueryFacts,
) -> list[dict]:

    system_prompt = render("system_prompt.jinja")

    if facts.entity == Entity.POLICY and facts.addr_start:
        body = render(
            "policy_by_address.jinja",
            query=user_query,
            facts=facts,
            rows=execution_result.get("rows", []),
        )

    elif facts.entity == Entity.POLICY and facts.operation == Operation.LIST:
        body = render(
            "policy_list.jinja",
            query=user_query,
            facts=facts,
            rows=execution_result.get("rows", []),
        )

    elif facts.entity == Entity.CATALOG:
        body = render(
            "project_catalog.jinja",
            rows=execution_result.get("rows", []),
        )

    else:
        body = render("empty_result.jinja")

    return [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": body},
    ]





from .base import render

def render_policy_by_address(query, rows):
    if not rows:
        return render("empty_result.jinja")

    return render(
        "policy_by_address.jinja",
        query=query,
        rows=rows,
    )


def render_policy_list(query, rows):
    if not rows:
        return render("empty_result.jinja")

    return render(
        "policy_list.jinja",
        query=query,
        rows=rows,
    )


from .base import render

def render_project_catalog(rows):
    if not rows:
        return render("empty_result.jinja")

    return render(
        "project_catalog.jinja",
        rows=rows,
    )

from .base import render

def render_policy_comparison(query, rows):
    if not rows:
        return render("empty_result.jinja")

    # You can add compare.jinja later
    return render(
        "policy_list.jinja",
        query=query,
        rows=rows,
    )





The user requested a list of MPU policies.

Project: {{ query.project }}
{% if query.version %}
Version: {{ query.version }}
{% else %}
Version: latest available
{% endif %}

{% if rows %}
Found {{ rows | length }} MPU policies:

{% for row in rows %}
- {{ row.mpu_name }}
  Region Index: {{ row.rg_index }}
  Address Range: 0x{{ "%X"|format(row.addr_start) }} ‚Äì 0x{{ "%X"|format(row.addr_end) }}
  Profile: {{ row.profile }}
{% endfor %}

{% else %}
No MPU policies were found.
{% endif %}



The user requested a catalog of supported projects.

{% if rows %}
Supported projects and latest versions:

{% for row in rows %}
- Project: {{ row.project }}
  Latest Version: {{ row.version }}
{% endfor %}

{% else %}
No project catalog information is available.
{% endif %}

No data was found for the given request.

This may be due to:
- Unsupported project
- No matching MPU regions
- Missing or invalid parameters

Please refine the query with more details if possible.







The user asked for MPU policy details for address {{ query.address }}.

Project: {{ query.project }}
{% if query.version %}
Version: {{ query.version }}
{% else %}
Version: latest available
{% endif %}

{% if rows %}
The following MPU regions cover this address:

{% for row in rows %}
- MPU: {{ row.mpu_name }}
  Region Index: {{ row.rg_index }}
  Address Range: 0x{{ "%X"|format(row.addr_start) }} ‚Äì 0x{{ "%X"|format(row.addr_end) }}
  Profile: {{ row.profile }}
  Explanation: {{ row.explanation }}
{% endfor %}

{% else %}
No MPU policy covers the given address.
{% endif %}





from pydantic import BaseModel, model_validator

class QueryFacts(BaseModel):
    ...

    @model_validator(mode="after")
    def validate_entity_rules(self):
        """
        Enforces cross-field validation after model is built
        """

        # Example rules
        if self.intent == Intent.POLICY and not self.entity:
            raise ValueError("POLICY intent requires at least one entity")

        if Entity.ADDRESS in self.entity:
            if not self.addr_start:
                raise ValueError("ADDRESS entity requires addr_start")

        if self.operation == Operation.LOOKUP and not self.project:
            raise ValueError("LOOKUP operation requires project")

        return self





from pydantic import BaseModel, Field, root_validator
from typing import Optional, List


class QueryFacts(BaseModel):
    intent: Intent
    operation: Operation
    entity: Entity

    # filters
    project: Optional[str] = None
    version: Optional[str] = None
    region: Optional[str] = None

    addr_start: Optional[int] = Field(
        None, description="Start address (decimal integer)"
    )
    addr_end: Optional[int] = Field(
        None, description="End address (decimal integer)"
    )

    # metadata
    raw_query: Optional[str] = None
    missing_required_fields: Optional[List[str]] = None

    @root_validator
    def validate_entity_rules(cls, values):
        """
        Hard safety rules so routing never breaks
        """
        entity = values.get("entity")
        intent = values.get("intent")
        operation = values.get("operation")

        # ADDRESS entity must have addr_start
        if entity == Entity.ADDRESS and not values.get("addr_start"):
            values["missing_required_fields"] = ["addr_start"]

        # POLICY LOOKUP by address is valid
        if intent == Intent.POLICY and operation == Operation.LOOKUP:
            if entity not in (Entity.POLICY, Entity.ADDRESS):
                raise ValueError("POLICY LOOKUP must use POLICY or ADDRESS entity")

        return values

INSTRUCTOR_PROMPT = """
You are extracting structured QueryFacts for a query planner.

CRITICAL RULES (MUST FOLLOW):
- Entity MUST be one of the allowed domain entities.
- DO NOT invent new entities.
- Hardware terms like "MPU", "core", "SoC", "cache" are CONTEXT ONLY.
- "MPU" must NEVER be an entity.
- Entity represents the DATA DOMAIN being queried, not the noun in the sentence.

ALLOWED ENTITIES:
- POLICY  ‚Üí MPU access policies
- PROJECT ‚Üí Project catalog
- VERSION ‚Üí Project versions
- REGION  ‚Üí Memory regions
- ADDRESS ‚Üí Address-based lookup

MAPPING RULES:
- "MPU access policy", "access policy", "policy" ‚Üí Entity.POLICY
- "list of policies" ‚Üí Entity.POLICY
- "supported projects" ‚Üí Entity.PROJECT
- "address 0x..." ‚Üí Entity.ADDRESS
- NEVER output Entity.MPU

ADDRESS RULES:
- If an address like 0xEF01000 is present:
  - Convert it to decimal integer
  - Set addr_start
  - Set entity = ADDRESS
  - Use operation = LOOKUP

OUTPUT FORMAT:
- Return ONLY valid JSON
- Must match the QueryFacts schema exactly
"""












You are a STRICT structured facts extraction engine for an MPU Access Policy RAG system.

Your ONLY job is to extract structured facts from the user query
and return a JSON object that EXACTLY matches the QueryFacts schema.

You must NOT:
- answer the question
- explain anything
- add fields
- rename fields
- change types
- infer data that is not explicitly stated

You must ONLY extract facts.

--------------------------------
DOMAIN DEFINITIONS
--------------------------------

INTENT (why the system is invoked):
- POLICY    ‚Üí retrieve MPU access policies or permissions
- CATALOG   ‚Üí list or count projects, versions, or supported items
- VALIDATE  ‚Üí allow/deny, is_allowed, safety checks
- EXPLAIN   ‚Üí conceptual explanation (no database lookup)
- UNKNOWN   ‚Üí unclear intent

OPERATION (how data is processed):
- LOOKUP   ‚Üí retrieve rows
- LIST     ‚Üí list multiple items
- COUNT    ‚Üí count items
- COMPARE  ‚Üí compare entities
- VALIDATE ‚Üí validation check
- EXPLAIN  ‚Üí explanation-only

ENTITY (WHAT domain object is queried):
- POLICY
- REGION
- PROJECT
- VERSION
- MPU
- ADDRESS

‚ö†Ô∏è ADDRESS is an ENTITY when a memory address or range is mentioned.

--------------------------------
ADDRESS EXTRACTION RULES
--------------------------------

- If the user mentions a hexadecimal address (example: 0x0EF01000),
  you MUST convert it to a decimal integer.

- If a SINGLE address is mentioned:
  ‚Üí addr_start = converted integer
  ‚Üí addr_end   = null

- If an address RANGE is mentioned (e.g. 0x1000‚Äì0x1FFF):
  ‚Üí addr_start = start of range
  ‚Üí addr_end   = end of range

- NEVER fabricate addr_end if it is not provided.

--------------------------------
CLASSIFICATION RULES
--------------------------------

- If the query asks for MPU access policy details using an address:
  intent    = POLICY
  operation = LOOKUP
  entity    = ["ADDRESS"]

- PROJECT must be extracted ONLY if explicitly mentioned.

- VERSION must be extracted ONLY if explicitly mentioned.
  Otherwise, return null.

--------------------------------
REQUIRED OUTPUT FORMAT
--------------------------------

Return ONE valid JSON object matching QueryFacts exactly:

{
  "intent": "POLICY | CATALOG | VALIDATE | EXPLAIN | UNKNOWN",
  "operation": "LOOKUP | LIST | COUNT | COMPARE | VALIDATE | EXPLAIN",
  "entity": ["ADDRESS", "..."],

  "project": string | null,
  "version": string | null,
  "mpu_name": string | null,

  "addr_start": integer | null,
  "addr_end": integer | null,

  "profile_type": string | null,
  "domains": list | null,

  "raw_query": string,
  "hyde_text": string,

  "confidence_hint": number
}

--------------------------------
MANDATORY RULES
--------------------------------

- raw_query MUST be the original user query verbatim.
- hyde_text MUST be copied verbatim from the provided HyDE text.
- entity MUST be a LIST (even if only one value).
- addr_start MUST be an integer (not hex).
- If a value is missing, return null.
- NEVER return empty strings.
- NEVER return additional fields.

--------------------------------
EXAMPLE
--------------------------------

User Query:
"Give me MPU access policy details for address 0x0EF01000 in project KAANAPALI"

Correct Output:
{
  "intent": "POLICY",
  "operation": "LOOKUP",
  "entity": ["ADDRESS"],
  "project": "KAANAPALI",
  "version": null,
  "mpu_name": null,
  "addr_start": 250613760,
  "addr_end": null,
  "profile_type": null,
  "domains": null,
  "raw_query": "Give me MPU access policy details for address 0x0EF01000 in project KAANAPALI",
  "hyde_text": "Retrieve MPU access policy details for address 0x0EF01000 in project KAANAPALI",
  "confidence_hint": 1.0
}






# executors/policy_by_address.py
from rag.executors.base import BaseExecutor, ExecutorError
from rag.query_helpers.queryfacts import QueryFacts

class PolicyByAddressExecutor(BaseExecutor):
    name = "policy_by_address"

    def execute(self, facts: QueryFacts):
        # ------------------
        # Validate inputs
        # ------------------
        if not facts.addr_start:
            raise ExecutorError("addr_start is required for policy_by_address")

        if not facts.project:
            raise ExecutorError("project is required for policy_by_address")

        # ------------------
        # Build SQL
        # ------------------
        query = self.sql.policy_by_address(
            project=facts.project,
            addr=facts.addr_start,
        )

        # ------------------
        # Execute
        # ------------------
        rows = self.run_query(query)

        # ------------------
        # Normalize rows
        # ------------------
        results = []
        for row in rows:
            results.append({
                "mpu_name": row[0],
                "policy_name": row[1],
                "addr_start": row[2],
                "addr_end": row[3],
                "profile_type": row[4],
                "domains": row[5],
            })

        # ------------------
        # Return contract
        # ------------------
        return {
            "rows": results,
            "explanation": f"MPU policies covering address {hex(facts.addr_start)}",
            "confidence": 0.95,
        }


# sql_query_builder.py
from pypika import Table, Query, Criterion

class SQLQueryBuilder:
    def __init__(self):
        self.xml = Table("xml_chunks")

    def policy_by_address(self, project: str, addr: int):
        return (
            Query.from_(self.xml)
            .select(
                self.xml.mpu_name,
                self.xml.policy_name,
                self.xml.addr_start,
                self.xml.addr_end,
                self.xml.profile_type,
                self.xml.domains,
            )
            .where(self.xml.project == project)
            .where(
                Criterion.all([
                    self.xml.addr_start <= addr,
                    self.xml.addr_end >= addr,
                ])
            )
        )




class BaseExecutor(ABC):
    def __init__(self, db, sql_builder):
        self.db = db
        self.sql = sql_builder

    @abstractmethod
    def execute(self, facts: QueryFacts) -> Dict[str, Any]:
        pass

    def run_query(self, query):
        """
        Executes SQL and ALWAYS returns List[Dict]
        This is the ONLY place DB rows are normalized.
        """
        with self.db.cursor() as cur:
            cur.execute(str(query))

            columns = [desc[0] for desc in cur.description]
            rows = cur.fetchall()

            results = [dict(zip(columns, row)) for row in rows]

            logger.debug(
                "DB returned %d rows with columns=%s",
                len(results),
                columns,
            )

            return results



context = f"""
You are answering a structured database query.

User question:
{user_query}

Query intent:
- Intent: {facts.intent}
- Operation: {facts.operation}

Database result summary:
{sql_context}

Guidelines:
- Do NOT list all records.
- Provide a concise summary.
- Mention total counts when available.
- Highlight patterns, categories, or notable observations.

Explainability:
{execution_result.get('explanation')}
"""

intent = facts.intent
operation = facts.operation
rows = execution_result.get("rows", [])

if operation == Operation.LIST:
    sql_context = f"""
Total MPU policies found: {len(rows)}

Sample policies (first 5):
{chr(10).join(
    f"- MPU={r.get('mpu_name', 'unknown')}, "
    f"addr={hex(r['addr_start']) if r.get('addr_start') else 'N/A'}"
    for r in rows[:5]
)}

Note: Full list is too large to display. Summarize categories or patterns.
"""






CRITICAL VALIDATION RULE:
- entity is a SINGLE ENUM VALUE
- entity MUST NOT be a list
- If multiple domains are mentioned, pick the PRIMARY one
- Address-based MPU access queries ‚Üí entity = POLICY




You are a STRICT QueryFacts extraction engine.

Your ONLY task:
Extract structured data that EXACTLY matches the QueryFacts schema.

You MUST NOT:
- Invent enum values
- Rename fields
- Add new fields
- Explain anything
- Answer the user question
- Change the meaning of enums
- Interpret execution strategy

You MUST:
- Copy raw_query verbatim
- Copy hyde_text verbatim
- Use ONLY allowed enum values
- Return EXACTLY one JSON object
- Return null for missing fields

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ALLOWED ENUM VALUES (MUST MATCH EXACTLY)

Intent (WHY the system is invoked):
- POLICY      ‚Üí MPU / address / access / region policy data
- CATALOG     ‚Üí listing projects / versions / supported data
- EXPLAIN     ‚Üí explanation-only, no database lookup
- VALIDATE    ‚Üí allow/deny / conflict / validation checks
- UNKNOWN     ‚Üí unclear intent

Operation (HOW data is accessed):
- LOOKUP
- LIST
- COUNT
- COMPARE
- EXPLAIN

Entity (WHAT domain is queried):
- POLICY
- PROJECT
- VERSION
- MPU
- REGION
- ADDRESS

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
FIELD EXTRACTION RULES

raw_query:
- Copy the original user query verbatim

hyde_text:
- Copy the Hyde-generated text verbatim

intent:
- Choose ONLY from Intent enum
- POLICY if the query refers to MPU, address, access, region, permissions
- CATALOG if the query lists projects or versions
- EXPLAIN if the query asks ‚Äúwhat is / why / how‚Äù
- VALIDATE if checking allowed / denied
- UNKNOWN otherwise

operation:
- LOOKUP for single retrieval
- LIST for enumeration
- COUNT for ‚Äúhow many‚Äù
- COMPARE for diff
- EXPLAIN for explanation-only queries

entity:
- Select ONE primary entity from the Entity enum
- Do NOT return lists
- POLICY is the default for MPU/address access questions

project:
- Extract ONLY if explicitly mentioned
- Else null

version:
- Extract ONLY if explicitly mentioned
- Else null

addr_start:
- If a single address is given (hex or decimal), convert to integer
- addr_end MUST be null unless a range is explicitly provided

addr_end:
- Extract ONLY if user explicitly provides an end address
- Never infer addr_end from addr_start

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
CRITICAL CONSTRAINTS

- Do NOT introduce new enum values (NO GENERAL, NO LOOKUP intent)
- REGION is an Entity, NOT an Intent
- PROFILE is NOT a valid Entity
- If unsure, return UNKNOWN intent
- Output MUST validate against QueryFacts Pydantic model

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
RETURN FORMAT

Return EXACTLY one JSON object matching QueryFacts.
No markdown. No explanation. No extra text.