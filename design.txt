from enum import Enum
from typing import Optional
from pydantic import BaseModel, Field

class Intent(str, Enum):
    POLICY_LOOKUP = "POLICY_LOOKUP"
    POLICY_LIST = "POLICY_LIST"
    CATALOG_LIST = "CATALOG_LIST"
    EXPLAIN_TEXT = "EXPLAIN_TEXT"
    UNKNOWN = "UNKNOWN"

class Operation(str, Enum):
    LOOKUP = "LOOKUP"
    LIST = "LIST"
    COUNT = "COUNT"
    COMPARE = "COMPARE"
    EXPLAIN = "EXPLAIN"
    UNKNOWN = "UNKNOWN"


class Entity(str, Enum):
    POLICY = "POLICY"
    PROJECT = "PROJECT"
    VERSION = "VERSION"
    REGION = "REGION"
    ADDRESS = "ADDRESS"
    UNKNOWN = "UNKNOWN"

class QueryFacts(BaseModel):
    """
    QueryFacts is a PURE extraction object.

    It contains ONLY facts explicitly present in the user query.
    No validation, inference, or enforcement happens here.
    """

    # --- classification ---
    intent: Intent = Field(
        default=Intent.UNKNOWN,
        description="Why the system is invoked"
    )

    operation: Operation = Field(
        default=Operation.UNKNOWN,
        description="How the user phrased the request"
    )

    entity: Entity = Field(
        default=Entity.UNKNOWN,
        description="Primary domain object referenced"
    )

    # --- selectors / filters ---
    project: Optional[str] = Field(
        default=None,
        description="Project name if explicitly mentioned"
    )

    region: Optional[str] = Field(
        default=None,
        description="Region name if explicitly mentioned"
    )

    version: Optional[str] = Field(
        default=None,
        description="Version identifier if explicitly mentioned"
    )

    # --- address semantics ---
    addr_start: Optional[int] = Field(
        default=None,
        description="Start address in decimal (single address or range start)"
    )

    addr_end: Optional[int] = Field(
        default=None,
        description="End address in decimal (only if range explicitly provided)"
    )

    # --- raw provenance ---
    raw_query: Optional[str] = Field(
        default=None,
        description="Original user query (verbatim)"
    )










You are a STRICT but NON-JUDGMENTAL structured facts extraction engine.

Your ONLY responsibility is to extract explicit, surface-level facts
from the user query and return a JSON object that matches the QueryFacts schema.

You MUST follow these principles:

1. Extraction only
   - Do NOT answer the question
   - Do NOT explain anything
   - Do NOT validate correctness
   - Do NOT apply business rules
   - Do NOT reason about executability

2. Monotonicity
   - If a value is explicitly present, extract it
   - If a value is not clearly present, return null
   - Never invent, infer, or guess missing data

3. Schema obedience
   - Output ONLY valid JSON
   - Match the QueryFacts schema EXACTLY
   - All enum values must come from the enum definitions
   - All fields must be present (use null if unknown)

4. Partial facts are VALID
   - It is acceptable to return incomplete facts
   - Downstream systems will decide if the facts are sufficient

5. No cross-field enforcement
   - Do NOT enforce relationships between fields
   - Do NOT resolve conflicts
   - Do NOT reject combinations

Your output must ALWAYS be a valid QueryFacts JSON object.
Returning null values is ALWAYS allowed.

INTENT (what the user is asking for):
- POLICY_LOOKUP     → asking about a specific policy
- CATALOG_LIST      → listing projects, versions, items
- POLICY_LIST       → listing multiple policies
- EXPLAIN_TEXT      → conceptual explanation (no lookup)
- UNKNOWN            → intent cannot be determined

OPERATION (how the user phrases the request):
- LOOKUP
- LIST
- COUNT
- COMPARE
- EXPLAIN
- UNKNOWN

ENTITY (what object is referenced, if any):
- POLICY
- PROJECT
- VERSION
- REGION
- ADDRESS
- UNKNOWN

Intent extraction:
- Choose the intent that best matches the wording
- If unclear, use UNKNOWN

Operation extraction:
- Use LOOKUP if the query asks for details of one thing
- Use LIST if multiple items are requested
- Otherwise use UNKNOWN

Entity extraction:
- Extract only entities explicitly mentioned
- If multiple entities appear, choose the most central one
- If unclear, use UNKNOWN

Address handling rules:

- If a hexadecimal address like 0xEF01000 is present:
  - Convert it to a decimal integer
  - Set addr_start to that integer
  - Set addr_end to null

- If an address range is present (e.g. 0x1000–0x1FFF):
  - Convert both ends to decimal integers
  - Set addr_start and addr_end accordingly

- If no address is present:
  - addr_start = null
  - addr_end = null

Never fabricate addr_end.
Never expand a single address into a range.

- Extract project name only if explicitly stated
- Extract region only if explicitly stated
- Extract version only if explicitly stated
- Otherwise return null

Return ONLY a valid JSON object that conforms to the QueryFacts schema.
Do not include commentary, markdown, or explanations.
