
from pydantic import BaseModel, Field, root_validator
from typing import Optional, List


class QueryFacts(BaseModel):
    intent: Intent
    operation: Operation
    entity: Entity

    # filters
    project: Optional[str] = None
    version: Optional[str] = None
    region: Optional[str] = None

    addr_start: Optional[int] = Field(
        None, description="Start address (decimal integer)"
    )
    addr_end: Optional[int] = Field(
        None, description="End address (decimal integer)"
    )

    # metadata
    raw_query: Optional[str] = None
    missing_required_fields: Optional[List[str]] = None

    @root_validator
    def validate_entity_rules(cls, values):
        """
        Hard safety rules so routing never breaks
        """
        entity = values.get("entity")
        intent = values.get("intent")
        operation = values.get("operation")

        # ADDRESS entity must have addr_start
        if entity == Entity.ADDRESS and not values.get("addr_start"):
            values["missing_required_fields"] = ["addr_start"]

        # POLICY LOOKUP by address is valid
        if intent == Intent.POLICY and operation == Operation.LOOKUP:
            if entity not in (Entity.POLICY, Entity.ADDRESS):
                raise ValueError("POLICY LOOKUP must use POLICY or ADDRESS entity")

        return values

INSTRUCTOR_PROMPT = """
You are extracting structured QueryFacts for a query planner.

CRITICAL RULES (MUST FOLLOW):
- Entity MUST be one of the allowed domain entities.
- DO NOT invent new entities.
- Hardware terms like "MPU", "core", "SoC", "cache" are CONTEXT ONLY.
- "MPU" must NEVER be an entity.
- Entity represents the DATA DOMAIN being queried, not the noun in the sentence.

ALLOWED ENTITIES:
- POLICY  → MPU access policies
- PROJECT → Project catalog
- VERSION → Project versions
- REGION  → Memory regions
- ADDRESS → Address-based lookup

MAPPING RULES:
- "MPU access policy", "access policy", "policy" → Entity.POLICY
- "list of policies" → Entity.POLICY
- "supported projects" → Entity.PROJECT
- "address 0x..." → Entity.ADDRESS
- NEVER output Entity.MPU

ADDRESS RULES:
- If an address like 0xEF01000 is present:
  - Convert it to decimal integer
  - Set addr_start
  - Set entity = ADDRESS
  - Use operation = LOOKUP

OUTPUT FORMAT:
- Return ONLY valid JSON
- Must match the QueryFacts schema exactly
"""












You are a STRICT structured facts extraction engine for an MPU Access Policy RAG system.

Your ONLY job is to extract structured facts from the user query
and return a JSON object that EXACTLY matches the QueryFacts schema.

You must NOT:
- answer the question
- explain anything
- add fields
- rename fields
- change types
- infer data that is not explicitly stated

You must ONLY extract facts.

--------------------------------
DOMAIN DEFINITIONS
--------------------------------

INTENT (why the system is invoked):
- POLICY    → retrieve MPU access policies or permissions
- CATALOG   → list or count projects, versions, or supported items
- VALIDATE  → allow/deny, is_allowed, safety checks
- EXPLAIN   → conceptual explanation (no database lookup)
- UNKNOWN   → unclear intent

OPERATION (how data is processed):
- LOOKUP   → retrieve rows
- LIST     → list multiple items
- COUNT    → count items
- COMPARE  → compare entities
- VALIDATE → validation check
- EXPLAIN  → explanation-only

ENTITY (WHAT domain object is queried):
- POLICY
- REGION
- PROJECT
- VERSION
- MPU
- ADDRESS

⚠️ ADDRESS is an ENTITY when a memory address or range is mentioned.

--------------------------------
ADDRESS EXTRACTION RULES
--------------------------------

- If the user mentions a hexadecimal address (example: 0x0EF01000),
  you MUST convert it to a decimal integer.

- If a SINGLE address is mentioned:
  → addr_start = converted integer
  → addr_end   = null

- If an address RANGE is mentioned (e.g. 0x1000–0x1FFF):
  → addr_start = start of range
  → addr_end   = end of range

- NEVER fabricate addr_end if it is not provided.

--------------------------------
CLASSIFICATION RULES
--------------------------------

- If the query asks for MPU access policy details using an address:
  intent    = POLICY
  operation = LOOKUP
  entity    = ["ADDRESS"]

- PROJECT must be extracted ONLY if explicitly mentioned.

- VERSION must be extracted ONLY if explicitly mentioned.
  Otherwise, return null.

--------------------------------
REQUIRED OUTPUT FORMAT
--------------------------------

Return ONE valid JSON object matching QueryFacts exactly:

{
  "intent": "POLICY | CATALOG | VALIDATE | EXPLAIN | UNKNOWN",
  "operation": "LOOKUP | LIST | COUNT | COMPARE | VALIDATE | EXPLAIN",
  "entity": ["ADDRESS", "..."],

  "project": string | null,
  "version": string | null,
  "mpu_name": string | null,

  "addr_start": integer | null,
  "addr_end": integer | null,

  "profile_type": string | null,
  "domains": list | null,

  "raw_query": string,
  "hyde_text": string,

  "confidence_hint": number
}

--------------------------------
MANDATORY RULES
--------------------------------

- raw_query MUST be the original user query verbatim.
- hyde_text MUST be copied verbatim from the provided HyDE text.
- entity MUST be a LIST (even if only one value).
- addr_start MUST be an integer (not hex).
- If a value is missing, return null.
- NEVER return empty strings.
- NEVER return additional fields.

--------------------------------
EXAMPLE
--------------------------------

User Query:
"Give me MPU access policy details for address 0x0EF01000 in project KAANAPALI"

Correct Output:
{
  "intent": "POLICY",
  "operation": "LOOKUP",
  "entity": ["ADDRESS"],
  "project": "KAANAPALI",
  "version": null,
  "mpu_name": null,
  "addr_start": 250613760,
  "addr_end": null,
  "profile_type": null,
  "domains": null,
  "raw_query": "Give me MPU access policy details for address 0x0EF01000 in project KAANAPALI",
  "hyde_text": "Retrieve MPU access policy details for address 0x0EF01000 in project KAANAPALI",
  "confidence_hint": 1.0
}






# executors/policy_by_address.py
from rag.executors.base import BaseExecutor, ExecutorError
from rag.query_helpers.queryfacts import QueryFacts

class PolicyByAddressExecutor(BaseExecutor):
    name = "policy_by_address"

    def execute(self, facts: QueryFacts):
        # ------------------
        # Validate inputs
        # ------------------
        if not facts.addr_start:
            raise ExecutorError("addr_start is required for policy_by_address")

        if not facts.project:
            raise ExecutorError("project is required for policy_by_address")

        # ------------------
        # Build SQL
        # ------------------
        query = self.sql.policy_by_address(
            project=facts.project,
            addr=facts.addr_start,
        )

        # ------------------
        # Execute
        # ------------------
        rows = self.run_query(query)

        # ------------------
        # Normalize rows
        # ------------------
        results = []
        for row in rows:
            results.append({
                "mpu_name": row[0],
                "policy_name": row[1],
                "addr_start": row[2],
                "addr_end": row[3],
                "profile_type": row[4],
                "domains": row[5],
            })

        # ------------------
        # Return contract
        # ------------------
        return {
            "rows": results,
            "explanation": f"MPU policies covering address {hex(facts.addr_start)}",
            "confidence": 0.95,
        }


# sql_query_builder.py
from pypika import Table, Query, Criterion

class SQLQueryBuilder:
    def __init__(self):
        self.xml = Table("xml_chunks")

    def policy_by_address(self, project: str, addr: int):
        return (
            Query.from_(self.xml)
            .select(
                self.xml.mpu_name,
                self.xml.policy_name,
                self.xml.addr_start,
                self.xml.addr_end,
                self.xml.profile_type,
                self.xml.domains,
            )
            .where(self.xml.project == project)
            .where(
                Criterion.all([
                    self.xml.addr_start <= addr,
                    self.xml.addr_end >= addr,
                ])
            )
        )




class BaseExecutor(ABC):
    def __init__(self, db, sql_builder):
        self.db = db
        self.sql = sql_builder

    @abstractmethod
    def execute(self, facts: QueryFacts) -> Dict[str, Any]:
        pass

    def run_query(self, query):
        """
        Executes SQL and ALWAYS returns List[Dict]
        This is the ONLY place DB rows are normalized.
        """
        with self.db.cursor() as cur:
            cur.execute(str(query))

            columns = [desc[0] for desc in cur.description]
            rows = cur.fetchall()

            results = [dict(zip(columns, row)) for row in rows]

            logger.debug(
                "DB returned %d rows with columns=%s",
                len(results),
                columns,
            )

            return results



context = f"""
You are answering a structured database query.

User question:
{user_query}

Query intent:
- Intent: {facts.intent}
- Operation: {facts.operation}

Database result summary:
{sql_context}

Guidelines:
- Do NOT list all records.
- Provide a concise summary.
- Mention total counts when available.
- Highlight patterns, categories, or notable observations.

Explainability:
{execution_result.get('explanation')}
"""

intent = facts.intent
operation = facts.operation
rows = execution_result.get("rows", [])

if operation == Operation.LIST:
    sql_context = f"""
Total MPU policies found: {len(rows)}

Sample policies (first 5):
{chr(10).join(
    f"- MPU={r.get('mpu_name', 'unknown')}, "
    f"addr={hex(r['addr_start']) if r.get('addr_start') else 'N/A'}"
    for r in rows[:5]
)}

Note: Full list is too large to display. Summarize categories or patterns.
"""






CRITICAL VALIDATION RULE:
- entity is a SINGLE ENUM VALUE
- entity MUST NOT be a list
- If multiple domains are mentioned, pick the PRIMARY one
- Address-based MPU access queries → entity = POLICY




You are a STRICT QueryFacts extraction engine.

Your ONLY task:
Extract structured data that EXACTLY matches the QueryFacts schema.

You MUST NOT:
- Invent enum values
- Rename fields
- Add new fields
- Explain anything
- Answer the user question
- Change the meaning of enums
- Interpret execution strategy

You MUST:
- Copy raw_query verbatim
- Copy hyde_text verbatim
- Use ONLY allowed enum values
- Return EXACTLY one JSON object
- Return null for missing fields

────────────────────────────────────
ALLOWED ENUM VALUES (MUST MATCH EXACTLY)

Intent (WHY the system is invoked):
- POLICY      → MPU / address / access / region policy data
- CATALOG     → listing projects / versions / supported data
- EXPLAIN     → explanation-only, no database lookup
- VALIDATE    → allow/deny / conflict / validation checks
- UNKNOWN     → unclear intent

Operation (HOW data is accessed):
- LOOKUP
- LIST
- COUNT
- COMPARE
- EXPLAIN

Entity (WHAT domain is queried):
- POLICY
- PROJECT
- VERSION
- MPU
- REGION
- ADDRESS

────────────────────────────────────
FIELD EXTRACTION RULES

raw_query:
- Copy the original user query verbatim

hyde_text:
- Copy the Hyde-generated text verbatim

intent:
- Choose ONLY from Intent enum
- POLICY if the query refers to MPU, address, access, region, permissions
- CATALOG if the query lists projects or versions
- EXPLAIN if the query asks “what is / why / how”
- VALIDATE if checking allowed / denied
- UNKNOWN otherwise

operation:
- LOOKUP for single retrieval
- LIST for enumeration
- COUNT for “how many”
- COMPARE for diff
- EXPLAIN for explanation-only queries

entity:
- Select ONE primary entity from the Entity enum
- Do NOT return lists
- POLICY is the default for MPU/address access questions

project:
- Extract ONLY if explicitly mentioned
- Else null

version:
- Extract ONLY if explicitly mentioned
- Else null

addr_start:
- If a single address is given (hex or decimal), convert to integer
- addr_end MUST be null unless a range is explicitly provided

addr_end:
- Extract ONLY if user explicitly provides an end address
- Never infer addr_end from addr_start

────────────────────────────────────
CRITICAL CONSTRAINTS

- Do NOT introduce new enum values (NO GENERAL, NO LOOKUP intent)
- REGION is an Entity, NOT an Intent
- PROFILE is NOT a valid Entity
- If unsure, return UNKNOWN intent
- Output MUST validate against QueryFacts Pydantic model

────────────────────────────────────
RETURN FORMAT

Return EXACTLY one JSON object matching QueryFacts.
No markdown. No explanation. No extra text.