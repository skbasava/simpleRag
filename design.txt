
curl -v \
  -X POST \
  https://ipcatalog-api.qualcomm.com/api/1/auth/token/login/ \
  -H "Content-Type: application/x-www-form-urlencoded" \
  --data "username=YOUR_USERNAME&password=YOUR_PASSWORD"


# rag/executors/sql_helpers.py

def regions_by_project(project: str, mpu_name: str | None = None):
    base = """
        SELECT DISTINCT region
        FROM mpu_regions
        WHERE project = :project
    """
    params = {"project": project}

    if mpu_name:
        base += " AND mpu_name = :mpu_name"
        params["mpu_name"] = mpu_name

    base += " ORDER BY region"
    return base, params

def region_count_by_project(project: str, mpu_name: str | None = None):
    base = """
        SELECT COUNT(DISTINCT region) AS count
        FROM mpu_regions
        WHERE project = :project
    """
    params = {"project": project}

    if mpu_name:
        base += " AND mpu_name = :mpu_name"
        params["mpu_name"] = mpu_name

    return base, params

# rag/executors/region_list.py

from rag.executors.base import BaseExecutor
from rag.query_helpers.models import QueryFacts
from rag.executors.sql_helpers import regions_by_project


class RegionListExecutor(BaseExecutor):
    name = "region_list"

    def execute(self, facts: QueryFacts):
        project = facts.project
        mpu_name = facts.mpu_name

        if not project:
            return self.fail("project is required")

        sql, params = regions_by_project(project, mpu_name)
        rows = self.run_query(sql, params)

        if not rows:
            return {
                "mode": "TEXT",
                "text": None,
                "rows": [],
                "confidence": 0.0,
                "explainability": "No regions found for the given project/MPU.",
                "sources": ["mpu_regions"],
            }

        regions = [r["region"] for r in rows]

        return {
            "mode": "LIST",
            "text": None,
            "rows": regions,
            "confidence": 1.0,
            "explainability": f"Regions supported in project {project}"
            + (f" for MPU {mpu_name}" if mpu_name else ""),
            "sources": ["mpu_regions"],
        }
# rag/executors/region_count.py

from rag.executors.base import BaseExecutor
from rag.query_helpers.models import QueryFacts
from rag.executors.sql_helpers import region_count_by_project


class RegionCountExecutor(BaseExecutor):
    name = "region_count"

    def execute(self, facts: QueryFacts):
        project = facts.project
        mpu_name = facts.mpu_name

        if not project:
            return self.fail("project is required")

        sql, params = region_count_by_project(project, mpu_name)
        rows = self.run_query(sql, params)

        count = rows[0]["count"] if rows else 0

        return {
            "mode": "TEXT",
            "text": str(count),
            "rows": None,
            "confidence": 1.0,
            "explainability": f"Number of regions in project {project}"
            + (f" for MPU {mpu_name}" if mpu_name else ""),
            "sources": ["mpu_regions"],
        }







REGION EXTRACTION RULES (HIGHEST PRIORITY):

- If the user mentions the word "region" followed by a number:
  - Extract that number as an integer
  - Set region = <number>
  - Set entity = REGION
  - Set operation = LOOKUP
  - DO NOT populate addr_start or addr_end

- Numeric values associated with "region" MUST NEVER be treated as addresses.

- If both a region number and an address are present:
  - Region number maps to region
  - Hexadecimal value maps to address

ADDRESS EXTRACTION GUARDRAILS:

- Treat a value as an ADDRESS ONLY IF:
  - It starts with "0x", OR
  - The word "address" explicitly appears

- Decimal numbers MUST NOT be treated as addresses unless explicitly labeled.






from enum import Enum
from typing import Optional
from pydantic import BaseModel, Field

class Intent(str, Enum):
    POLICY_LOOKUP = "POLICY_LOOKUP"
    POLICY_LIST = "POLICY_LIST"
    CATALOG_LIST = "CATALOG_LIST"
    EXPLAIN_TEXT = "EXPLAIN_TEXT"
    UNKNOWN = "UNKNOWN"

class Operation(str, Enum):
    LOOKUP = "LOOKUP"
    LIST = "LIST"
    COUNT = "COUNT"
    COMPARE = "COMPARE"
    EXPLAIN = "EXPLAIN"
    UNKNOWN = "UNKNOWN"


class Entity(str, Enum):
    POLICY = "POLICY"
    PROJECT = "PROJECT"
    VERSION = "VERSION"
    REGION = "REGION"
    ADDRESS = "ADDRESS"
    UNKNOWN = "UNKNOWN"

class QueryFacts(BaseModel):
    """
    QueryFacts is a PURE extraction object.

    It contains ONLY facts explicitly present in the user query.
    No validation, inference, or enforcement happens here.
    """

    # --- classification ---
    intent: Intent = Field(
        default=Intent.UNKNOWN,
        description="Why the system is invoked"
    )

    operation: Operation = Field(
        default=Operation.UNKNOWN,
        description="How the user phrased the request"
    )

    entity: Entity = Field(
        default=Entity.UNKNOWN,
        description="Primary domain object referenced"
    )

    # --- selectors / filters ---
    project: Optional[str] = Field(
        default=None,
        description="Project name if explicitly mentioned"
    )

    region: Optional[str] = Field(
        default=None,
        description="Region name if explicitly mentioned"
    )

    version: Optional[str] = Field(
        default=None,
        description="Version identifier if explicitly mentioned"
    )

    # --- address semantics ---
    addr_start: Optional[int] = Field(
        default=None,
        description="Start address in decimal (single address or range start)"
    )

    addr_end: Optional[int] = Field(
        default=None,
        description="End address in decimal (only if range explicitly provided)"
    )

    # --- raw provenance ---
    raw_query: Optional[str] = Field(
        default=None,
        description="Original user query (verbatim)"
    )










You are a STRICT but NON-JUDGMENTAL structured facts extraction engine.

Your ONLY responsibility is to extract explicit, surface-level facts
from the user query and return a JSON object that matches the QueryFacts schema.

You MUST follow these principles:

1. Extraction only
   - Do NOT answer the question
   - Do NOT explain anything
   - Do NOT validate correctness
   - Do NOT apply business rules
   - Do NOT reason about executability

2. Monotonicity
   - If a value is explicitly present, extract it
   - If a value is not clearly present, return null
   - Never invent, infer, or guess missing data

3. Schema obedience
   - Output ONLY valid JSON
   - Match the QueryFacts schema EXACTLY
   - All enum values must come from the enum definitions
   - All fields must be present (use null if unknown)

4. Partial facts are VALID
   - It is acceptable to return incomplete facts
   - Downstream systems will decide if the facts are sufficient

5. No cross-field enforcement
   - Do NOT enforce relationships between fields
   - Do NOT resolve conflicts
   - Do NOT reject combinations

Your output must ALWAYS be a valid QueryFacts JSON object.
Returning null values is ALWAYS allowed.

INTENT (what the user is asking for):
- POLICY_LOOKUP     → asking about a specific policy
- CATALOG_LIST      → listing projects, versions, items
- POLICY_LIST       → listing multiple policies
- EXPLAIN_TEXT      → conceptual explanation (no lookup)
- UNKNOWN            → intent cannot be determined

OPERATION (how the user phrases the request):
- LOOKUP
- LIST
- COUNT
- COMPARE
- EXPLAIN
- UNKNOWN

ENTITY (what object is referenced, if any):
- POLICY
- PROJECT
- VERSION
- REGION
- ADDRESS
- UNKNOWN

Intent extraction:
- Choose the intent that best matches the wording
- If unclear, use UNKNOWN

Operation extraction:
- Use LOOKUP if the query asks for details of one thing
- Use LIST if multiple items are requested
- Otherwise use UNKNOWN

Entity extraction:
- Extract only entities explicitly mentioned
- If multiple entities appear, choose the most central one
- If unclear, use UNKNOWN

Address handling rules:

- If a hexadecimal address like 0xEF01000 is present:
  - Convert it to a decimal integer
  - Set addr_start to that integer
  - Set addr_end to null

- If an address range is present (e.g. 0x1000–0x1FFF):
  - Convert both ends to decimal integers
  - Set addr_start and addr_end accordingly

- If no address is present:
  - addr_start = null
  - addr_end = null

Never fabricate addr_end.
Never expand a single address into a range.

- Extract project name only if explicitly stated
- Extract region only if explicitly stated
- Extract version only if explicitly stated
- Otherwise return null

Return ONLY a valid JSON object that conforms to the QueryFacts schema.
Do not include commentary, markdown, or explanations.
