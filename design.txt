
import yaml
from pathlib import Path

def load_kshot_examples(
    path: str | Path,
    max_examples: int | None = None,
) -> list[dict]:
    path = Path(path)
    with path.open("r", encoding="utf-8") as f:
        data = yaml.safe_load(f)

    shots = data.get("kshots", [])
    if max_examples is not None:
        shots = shots[:max_examples]
    return shots

def build_sql_context(rows: list[dict]) -> str:
    if not rows:
        return "SQL Context:\n(empty)"

    lines = ["SQL Context:"]
    for i, row in enumerate(rows, start=1):
        lines.append(f"\nRegion {i}:")
        for key, value in row.items():
            if value is None:
                continue
            lines.append(f"- {key}: {value}")
    return "\n".join(lines)

def render_kshots(kshots: list[dict]) -> str:
    blocks = []
    for shot in kshots:
        block = f"""
### K-SHOT EXAMPLE: {shot.get("description")}

User Query:
{shot.get("user_query")}

SQL Context:
{shot.get("sql_context")}

Answer:
{shot.get("answer")}
""".strip()
        blocks.append(block)

    return "\n\n".join(blocks)



where_params = []
    for cond in self.conditions:
        if cond == "project = %s":
            where_params.append(self.filters["project"])
        elif cond == "version = %s":
            where_params.append(self.filters["version"])
        elif cond == "mpu_name = %s":
            where_params.append(self.filters["mpu_name"])
        elif cond == "profile = %s":
            where_params.append(self.filters["profile"])
        elif cond == "addr_start <= %s":
            where_params.append(effective_end)
        elif cond == "addr_end >= %s":
            where_params.append(addr_start)

    # ---- final SQL ----
    sql = f"""
    {select_sql}
    {where_clause}
    {order_clause}
    {limit_clause}
    """.strip()

    final_params = explain_params + where_params

    # ---- defensive check ----
    assert sql.count("%s") == len(final_params), (
        f"SQL placeholders={sql.count('%s')} "
        f"params={len(final_params)}"
    )

    return sql, final_params


def explain_region_choice(
    row: dict,
    query_start: int | None,
    query_end: int | None,
    is_point: bool,
) -> str | None:
    """
    Generates explainability text STRICTLY from SQL-computed facts.

    Defensive guarantees:
    - No KeyError
    - No hallucination
    - No inference beyond SQL results
    - Returns None if explainability is not justified
    """

    if not isinstance(row, dict):
        return None

    # Required base fields
    addr_start = row.get("addr_start")
    addr_end = row.get("addr_end")
    rg_index = row.get("rg_index")

    if addr_start is None or addr_end is None:
        return None

    # ---------- POINT ADDRESS QUERY ----------
    if is_point:
        covers = row.get("covers_address")
        region_size = row.get("region_size")

        if covers is not True or region_size is None:
            return None

        return (
            f"Address 0x{query_start:X} is covered by MPU region "
            f"[0x{addr_start:X}–0x{addr_end:X}]. "
            f"This region was selected because it is the most specific match "
            f"(region size = {region_size} bytes)"
            + (f" with priority rg_index={rg_index}." if rg_index is not None else ".")
        )

    # ---------- RANGE ADDRESS QUERY ----------
    overlap = row.get("effective_overlap_size")

    if overlap is None or overlap <= 0:
        return None

    return (
        f"Address range [0x{query_start:X}–0x{query_end:X}] overlaps with MPU region "
        f"[0x{addr_start:X}–0x{addr_end:X}] "
        f"(overlap size = {overlap} bytes)."
    )




def _apply_version(self):
    version = self.filters.get("version")

    if version:
        self.conditions.append("version = %s")
        self.params.append(version)
        return

    # Version not provided → resolve latest
    project = self.filters.get("project")
    if project and self.version_resolver:
        resolved = self.version_resolver(project)
        if resolved:
            self.conditions.append("version = %s")
            self.params.append(resolved)


def _sql_search(self, params: dict) -> list[dict]:
    """
    Executes deterministic SQL path and enriches rows with
    classification + explainability.
    """
    logger.info(
        "Entering _sql_search with params: %s",
        _safe_params_for_log(params)
    )

    facts = QueryFacts(**params)

    # ---- Run SQL path ----
    rows = self.run_sql_path(facts)

    if not rows:
        logger.info("SQL returned no rows")
        return []

    # ---- Enrich rows (pure functions) ----
    enriched = []
    for row in rows:
        # classification
        cls = classify_policy(
            row["addr_start"],
            row["addr_end"],
            row.get("profile"),
        )
        row.update(cls)

        # explainability
        if facts.addr_start is not None:
            row["explanation"] = explain_region_choice(
                row=row,
                query_start=facts.addr_start,
                query_end=facts.addr_end,
            )

        enriched.append(row)

    return enriched