# sql_query_builder.py
from pypika import Table, Query, Criterion

class SQLQueryBuilder:
    def __init__(self):
        self.xml = Table("xml_chunks")

    def policy_by_address(self, project: str, addr: int):
        return (
            Query.from_(self.xml)
            .select(
                self.xml.mpu_name,
                self.xml.policy_name,
                self.xml.addr_start,
                self.xml.addr_end,
                self.xml.profile_type,
                self.xml.domains,
            )
            .where(self.xml.project == project)
            .where(
                Criterion.all([
                    self.xml.addr_start <= addr,
                    self.xml.addr_end >= addr,
                ])
            )
        )




class BaseExecutor(ABC):
    def __init__(self, db, sql_builder):
        self.db = db
        self.sql = sql_builder

    @abstractmethod
    def execute(self, facts: QueryFacts) -> Dict[str, Any]:
        pass

    def run_query(self, query):
        """
        Executes SQL and ALWAYS returns List[Dict]
        This is the ONLY place DB rows are normalized.
        """
        with self.db.cursor() as cur:
            cur.execute(str(query))

            columns = [desc[0] for desc in cur.description]
            rows = cur.fetchall()

            results = [dict(zip(columns, row)) for row in rows]

            logger.debug(
                "DB returned %d rows with columns=%s",
                len(results),
                columns,
            )

            return results



context = f"""
You are answering a structured database query.

User question:
{user_query}

Query intent:
- Intent: {facts.intent}
- Operation: {facts.operation}

Database result summary:
{sql_context}

Guidelines:
- Do NOT list all records.
- Provide a concise summary.
- Mention total counts when available.
- Highlight patterns, categories, or notable observations.

Explainability:
{execution_result.get('explanation')}
"""

intent = facts.intent
operation = facts.operation
rows = execution_result.get("rows", [])

if operation == Operation.LIST:
    sql_context = f"""
Total MPU policies found: {len(rows)}

Sample policies (first 5):
{chr(10).join(
    f"- MPU={r.get('mpu_name', 'unknown')}, "
    f"addr={hex(r['addr_start']) if r.get('addr_start') else 'N/A'}"
    for r in rows[:5]
)}

Note: Full list is too large to display. Summarize categories or patterns.
"""






CRITICAL VALIDATION RULE:
- entity is a SINGLE ENUM VALUE
- entity MUST NOT be a list
- If multiple domains are mentioned, pick the PRIMARY one
- Address-based MPU access queries → entity = POLICY




You are a STRICT QueryFacts extraction engine.

Your ONLY task:
Extract structured data that EXACTLY matches the QueryFacts schema.

You MUST NOT:
- Invent enum values
- Rename fields
- Add new fields
- Explain anything
- Answer the user question
- Change the meaning of enums
- Interpret execution strategy

You MUST:
- Copy raw_query verbatim
- Copy hyde_text verbatim
- Use ONLY allowed enum values
- Return EXACTLY one JSON object
- Return null for missing fields

────────────────────────────────────
ALLOWED ENUM VALUES (MUST MATCH EXACTLY)

Intent (WHY the system is invoked):
- POLICY      → MPU / address / access / region policy data
- CATALOG     → listing projects / versions / supported data
- EXPLAIN     → explanation-only, no database lookup
- VALIDATE    → allow/deny / conflict / validation checks
- UNKNOWN     → unclear intent

Operation (HOW data is accessed):
- LOOKUP
- LIST
- COUNT
- COMPARE
- EXPLAIN

Entity (WHAT domain is queried):
- POLICY
- PROJECT
- VERSION
- MPU
- REGION
- ADDRESS

────────────────────────────────────
FIELD EXTRACTION RULES

raw_query:
- Copy the original user query verbatim

hyde_text:
- Copy the Hyde-generated text verbatim

intent:
- Choose ONLY from Intent enum
- POLICY if the query refers to MPU, address, access, region, permissions
- CATALOG if the query lists projects or versions
- EXPLAIN if the query asks “what is / why / how”
- VALIDATE if checking allowed / denied
- UNKNOWN otherwise

operation:
- LOOKUP for single retrieval
- LIST for enumeration
- COUNT for “how many”
- COMPARE for diff
- EXPLAIN for explanation-only queries

entity:
- Select ONE primary entity from the Entity enum
- Do NOT return lists
- POLICY is the default for MPU/address access questions

project:
- Extract ONLY if explicitly mentioned
- Else null

version:
- Extract ONLY if explicitly mentioned
- Else null

addr_start:
- If a single address is given (hex or decimal), convert to integer
- addr_end MUST be null unless a range is explicitly provided

addr_end:
- Extract ONLY if user explicitly provides an end address
- Never infer addr_end from addr_start

────────────────────────────────────
CRITICAL CONSTRAINTS

- Do NOT introduce new enum values (NO GENERAL, NO LOOKUP intent)
- REGION is an Entity, NOT an Intent
- PROFILE is NOT a valid Entity
- If unsure, return UNKNOWN intent
- Output MUST validate against QueryFacts Pydantic model

────────────────────────────────────
RETURN FORMAT

Return EXACTLY one JSON object matching QueryFacts.
No markdown. No explanation. No extra text.