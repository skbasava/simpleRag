
str:
        return (
            "ParsedRegion("
            f"project={self.project}, "
            f"version={self.version}, "
            f"mpu={self.mpu_name}, "
            f"rg_index={self.rg_index}, "
            f"addr=0x{self.addr_start:X}-0x{self.addr_end:X}, "
            f"profile={self.profile or 'âˆ…'}, "
            f"read_domains={self.read_domains}, "
            f"write_domains={self.write_domains}"
            ")"
        )


def debug_print_region(region, prefix="REGION"):
    print(f"\n[{prefix}]")
    print(f"  project      : {region.project}")
    print(f"  version      : {region.version}")
    print(f"  mpu_name     : {region.mpu_name}")
    print(f"  rg_index     : {region.rg_index}")
    print(f"  addr_start   : {hex(region.addr_start) if region.addr_start is not None else None}")
    print(f"  addr_end     : {hex(region.addr_end) if region.addr_end is not None else None}")
    print(f"  profile      : {getattr(region, 'profile', None)}")
    print(f"  read_domains : {region.read_domains} (type={type(region.read_domains)})")
    print(f"  write_domains: {region.write_domains} (type={type(region.write_domains)})")
    print(f"  raw_text     : {region.raw_text[:120]}...")

def compute_chunk_hash(region: ParsedRegion) -> str:
    h = hashlib.sha256()
    h.update(region.project.encode())
    h.update(region.version.encode())
    h.update(region.mpu_name.encode())
    h.update(str(region.rg_index).encode())
    h.update(str(region.addr_start).encode())
    h.update(str(region.addr_end).encode())
    h.update(region.profile.encode())
    h.update(region.raw_text.encode())
    return h.hexdigest()

def embed_and_store(
    conn,
    embed_fn,
    regions: list,
):
    """
    conn      : psycopg2 connection
    embed_fn  : callable(text) -> list[float]
    regions   : list[ParsedRegion]
    """

    sql = """
    INSERT INTO policy_chunks (
        project,
        version,
        mpu_name,
        rg_index,
        addr_start,
        addr_end,
        read_domains,
        write_domains,
        raw_text,
        embedding
    )
    VALUES (
        %(project)s,
        %(version)s,
        %(mpu_name)s,
        %(rg_index)s,
        %(addr_start)s,
        %(addr_end)s,
        %(read_domains)s,
        %(write_domains)s,
        %(raw_text)s,
        %(embedding)s
    )
    """

    with conn.cursor() as cur:
        for region in regions:
            # ---------- hard safety checks ----------
            if region.addr_start is None or region.addr_end is None:
                continue

            if region.addr_start > region.addr_end:
                continue

            # ---------- build semantic text ----------
            embed_text = build_embedding_text(region)

            # ---------- generate vector ----------
            embedding = embed_fn(embed_text)

            # ---------- store ----------
            cur.execute(
                sql,
                {
                    "project": region.project,
                    "version": region.version,
                    "mpu_name": region.mpu_name,
                    "rg_index": region.rg_index,
                    "addr_start": region.addr_start,
                    "addr_end": region.addr_end,
                    "read_domains": region.read_domains or [],
                    "write_domains": region.write_domains or [],
                    "raw_text": region.raw_text,
                    "embedding": embedding,
                },
            )

        conn.commit()








import re
from typing import Optional
from dataclasses import dataclass


@dataclass(frozen=True)
class QueryFacts:
    project: Optional[str] = None
    version: Optional[str] = None
    addr: Optional[int] = None
    mpu: Optional[str] = None


# --- regex ---
HEX_ADDR_RE = re.compile(r"0x[0-9a-fA-F]+")
VERSION_RE = re.compile(r"\b(\d+\.\d+)\b")
PROJECT_RE = re.compile(r"\b(KAANAPALLI|HAWI|WAIPIO|KAILUA)\b", re.I)
MPU_RE = re.compile(r"\b[A-Z0-9_]+_MPU_[A-Z0-9_]+\b", re.I)


def extract_query_facts(user_query: str) -> QueryFacts:
    text = user_query.upper()

    # Address
    addr = None
    m = HEX_ADDR_RE.search(text)
    if m:
        addr = int(m.group(), 16)

    # Version
    version = None
    m = VERSION_RE.search(text)
    if m:
        version = m.group(1)

    # Project
    project = None
    m = PROJECT_RE.search(text)
    if m:
        project = m.group(1)

    # MPU
    mpu = None
    m = MPU_RE.search(text)
    if m:
        mpu = m.group()

    return QueryFacts(
        project=project,
        version=version,
        addr=addr,
        mpu=mpu,
    )

def generate_hyde_text(
    user_query: str,
    facts: QueryFacts,
    llm,
) -> str:
    """
    Generate HyDE-style technical rewrite for embedding only.
    Output is NOT used for SQL.
    """

    system_prompt = """
You rewrite user questions into precise technical search statements.

Rules:
- Do NOT invent MPU names, addresses, or permissions
- Use only provided facts
- Write in neutral, technical language
- One paragraph only
"""

    constraints = []

    if facts.project:
        constraints.append(f"Project: {facts.project}")
    if facts.version:
        constraints.append(f"Version: {facts.version}")
    if facts.mpu:
        constraints.append(f"MPU: {facts.mpu}")
    if facts.addr is not None:
        constraints.append(f"Address: 0x{facts.addr:X}")

    constraint_text = "\n".join(constraints)

    user_prompt = f"""
Original query:
{user_query}

Known facts:
{constraint_text}

Rewrite as a technical statement describing the MPU access-control policy being queried.
"""

    rewritten = llm.ask(
        prompt=user_prompt,
        system_prompt=system_prompt,
        temperature=0.0,   # critical: no creativity
        max_tokens=120,
    )

    return rewritten.strip()














def build_chunk_text(
    *,
    project: str | None,
    version: str | None,
    mpu_name: str | None,
    region_index: int | None,
    addr_start: int | None,
    addr_end: int | None,
    policy_text: str,
) -> str:
    """
    Build embedding-optimized chunk text with structured metadata labels.

    This text is ONLY for embedding + vector search.
    """

    labels = []

    if project:
        labels.append(f"[PROJECT={project}]")

    if version:
        labels.append(f"[VERSION={version}]")

    if mpu_name:
        labels.append(f"[MPU={mpu_name}]")

    if region_index is not None:
        labels.append(f"[REGION={region_index}]")

    if addr_start is not None:
        labels.append(f"[ADDR_START=0x{addr_start:X}]")

    if addr_end is not None:
        labels.append(f"[ADDR_END=0x{addr_end:X}]")

    # ---- final chunk text ----
    # metadata first, policy content second
    chunk_text = "\n".join(labels)
    chunk_text += "\n\n"
    chunk_text += policy_text.strip()

    return chunk_text



You are a technical query rewriter for a retrieval system.

Your task:
Rewrite the user query into a precise technical statement that describes
an MPU access-control policy.

Rules:
- Do NOT answer the question
- Do NOT explain concepts
- Do NOT invent values
- Only restate the query as a factual policy description
- Use the same metadata labels used during ingestion when possible

Allowed labels (use only if mentioned or clearly implied):
[PROJECT=...]
[VERSION=...]
[MPU=...]
[REGION=...]
[ADDR_START=0x...]
[ADDR_END=0x...]

If an exact value is not known, omit the label.

The output must be a short technical paragraph, not bullet points.




# Step 1: vector recall
candidate_ids = vector_search(query_embedding)

# Step 2: SQL truth filter
rows = sql_fetch(
    candidate_ids=candidate_ids,
    project=project,
    version=latest,
    address=query_address
)

# Step 3: rank + explain
ranked = rerank(rows)




filters = {
    "candidate_chunk_ids": [12, 47, 103, 208],
    "project": "KAANAPALLI",
    "version": "latest",
    "mpu_name": None,
    "region": None,
    "query_address": 0xC210000,
}

output expected 

SELECT ...
FROM policy_chunks
WHERE id = ANY(%(candidate_chunk_ids)s)
  AND project = %(project)s
  AND version = (
        SELECT MAX(version)
        FROM policy_chunks
        WHERE project = %(project)s
  )
  AND addr_start <= %(query_address)s
  AND addr_end >= %(query_address)s

{
  "candidate_chunk_ids": [12, 47, 103, 208],
  "project": "KAANAPALLI",
  "query_address": 0xC210000
}










def build_policy_sql(filters: dict) -> tuple[str, dict]:
    """
    Build a safe, parameterized SQL query for policy retrieval.

    Expected filters keys:
      - candidate_chunk_ids: list[int] (REQUIRED)
      - project: str | None
      - version: str | "latest" | None
      - mpu_name: str | None
      - region: int | None
      - query_address: int | None

    Returns:
      (sql_query, sql_params)
    """

    if not filters.get("candidate_chunk_ids"):
        raise ValueError("candidate_chunk_ids is required for SQL filtering")

    where_clauses = []
    params = {}

    # --- Candidate gating (mandatory) ---
    where_clauses.append("id = ANY(%(candidate_chunk_ids)s)")
    params["candidate_chunk_ids"] = filters["candidate_chunk_ids"]

    # --- Project ---
    if filters.get("project"):
        where_clauses.append("project = %(project)s")
        params["project"] = filters["project"]

    # --- Version ---
    version = filters.get("version")
    if version and version != "latest":
        where_clauses.append("version = %(version)s")
        params["version"] = version
    elif version == "latest":
        where_clauses.append(
            "version = (SELECT MAX(version) FROM policy_chunks WHERE project = %(project)s)"
        )
        params["project"] = filters.get("project")

    # --- MPU ---
    if filters.get("mpu_name"):
        where_clauses.append("mpu_name = %(mpu_name)s")
        params["mpu_name"] = filters["mpu_name"]

    # --- Region ---
    if filters.get("region") is not None:
        where_clauses.append("rg_index = %(region)s")
        params["region"] = filters["region"]

    # --- Address containment ---
    if filters.get("query_address") is not None:
        where_clauses.append(
            "(addr_start <= %(query_address)s AND addr_end >= %(query_address)s)"
        )
        params["query_address"] = filters["query_address"]

    # --- Final SQL ---
    sql = f"""
        SELECT
            id,
            project,
            version,
            mpu_name,
            rg_index,
            addr_start,
            addr_end,
            raw_text,
            embedding
        FROM policy_chunks
        WHERE {" AND ".join(where_clauses)}
    """

    return sql.strip(), params
