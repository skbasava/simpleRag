def build_chunk_text(
    *,
    project: str | None,
    version: str | None,
    mpu_name: str | None,
    region_index: int | None,
    addr_start: int | None,
    addr_end: int | None,
    policy_text: str,
) -> str:
    """
    Build embedding-optimized chunk text with structured metadata labels.

    This text is ONLY for embedding + vector search.
    """

    labels = []

    if project:
        labels.append(f"[PROJECT={project}]")

    if version:
        labels.append(f"[VERSION={version}]")

    if mpu_name:
        labels.append(f"[MPU={mpu_name}]")

    if region_index is not None:
        labels.append(f"[REGION={region_index}]")

    if addr_start is not None:
        labels.append(f"[ADDR_START=0x{addr_start:X}]")

    if addr_end is not None:
        labels.append(f"[ADDR_END=0x{addr_end:X}]")

    # ---- final chunk text ----
    # metadata first, policy content second
    chunk_text = "\n".join(labels)
    chunk_text += "\n\n"
    chunk_text += policy_text.strip()

    return chunk_text



You are a technical query rewriter for a retrieval system.

Your task:
Rewrite the user query into a precise technical statement that describes
an MPU access-control policy.

Rules:
- Do NOT answer the question
- Do NOT explain concepts
- Do NOT invent values
- Only restate the query as a factual policy description
- Use the same metadata labels used during ingestion when possible

Allowed labels (use only if mentioned or clearly implied):
[PROJECT=...]
[VERSION=...]
[MPU=...]
[REGION=...]
[ADDR_START=0x...]
[ADDR_END=0x...]

If an exact value is not known, omit the label.

The output must be a short technical paragraph, not bullet points.




# Step 1: vector recall
candidate_ids = vector_search(query_embedding)

# Step 2: SQL truth filter
rows = sql_fetch(
    candidate_ids=candidate_ids,
    project=project,
    version=latest,
    address=query_address
)

# Step 3: rank + explain
ranked = rerank(rows)




filters = {
    "candidate_chunk_ids": [12, 47, 103, 208],
    "project": "KAANAPALLI",
    "version": "latest",
    "mpu_name": None,
    "region": None,
    "query_address": 0xC210000,
}

output expected 

SELECT ...
FROM policy_chunks
WHERE id = ANY(%(candidate_chunk_ids)s)
  AND project = %(project)s
  AND version = (
        SELECT MAX(version)
        FROM policy_chunks
        WHERE project = %(project)s
  )
  AND addr_start <= %(query_address)s
  AND addr_end >= %(query_address)s

{
  "candidate_chunk_ids": [12, 47, 103, 208],
  "project": "KAANAPALLI",
  "query_address": 0xC210000
}










def build_policy_sql(filters: dict) -> tuple[str, dict]:
    """
    Build a safe, parameterized SQL query for policy retrieval.

    Expected filters keys:
      - candidate_chunk_ids: list[int] (REQUIRED)
      - project: str | None
      - version: str | "latest" | None
      - mpu_name: str | None
      - region: int | None
      - query_address: int | None

    Returns:
      (sql_query, sql_params)
    """

    if not filters.get("candidate_chunk_ids"):
        raise ValueError("candidate_chunk_ids is required for SQL filtering")

    where_clauses = []
    params = {}

    # --- Candidate gating (mandatory) ---
    where_clauses.append("id = ANY(%(candidate_chunk_ids)s)")
    params["candidate_chunk_ids"] = filters["candidate_chunk_ids"]

    # --- Project ---
    if filters.get("project"):
        where_clauses.append("project = %(project)s")
        params["project"] = filters["project"]

    # --- Version ---
    version = filters.get("version")
    if version and version != "latest":
        where_clauses.append("version = %(version)s")
        params["version"] = version
    elif version == "latest":
        where_clauses.append(
            "version = (SELECT MAX(version) FROM policy_chunks WHERE project = %(project)s)"
        )
        params["project"] = filters.get("project")

    # --- MPU ---
    if filters.get("mpu_name"):
        where_clauses.append("mpu_name = %(mpu_name)s")
        params["mpu_name"] = filters["mpu_name"]

    # --- Region ---
    if filters.get("region") is not None:
        where_clauses.append("rg_index = %(region)s")
        params["region"] = filters["region"]

    # --- Address containment ---
    if filters.get("query_address") is not None:
        where_clauses.append(
            "(addr_start <= %(query_address)s AND addr_end >= %(query_address)s)"
        )
        params["query_address"] = filters["query_address"]

    # --- Final SQL ---
    sql = f"""
        SELECT
            id,
            project,
            version,
            mpu_name,
            rg_index,
            addr_start,
            addr_end,
            raw_text,
            embedding
        FROM policy_chunks
        WHERE {" AND ".join(where_clauses)}
    """

    return sql.strip(), params
