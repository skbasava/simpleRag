
class Planner:
    def plan(self, facts: QueryFacts) -> ExecutionPlan:

        if not facts.intent:
            return ExecutionPlan(
                steps=[
                    PlanStep(
                        action="CLARIFY",
                        params={"reason": "Missing intent"}
                    )
                ],
                reason="Insufficient facts"
            )

        intent = facts.intent.upper()

        # ADDRESS LOOKUP â†’ SQL + VECTOR fallback
        if intent == "ADDRESS_LOOKUP":
            return ExecutionPlan(
                reason="Address lookup with fallback",
                steps=[
                    PlanStep(
                        action="SQL_SEARCH",
                        params={
                            "project": facts.project,
                            "version": facts.version,
                            "mpu_name": facts.mpu_name,
                        },
                    ),
                    PlanStep(
                        action="VECTOR_SEARCH",
                        deps=[0],
                        params={
                            "query_text": facts.raw_text,
                            "filters": {"project": facts.project},
                        },
                    ),
                ],
            )

        # POLICY LOOKUP â†’ SQL only
        if intent == "POLICY_LOOKUP":
            return ExecutionPlan(
                reason="Structured policy lookup",
                steps=[
                    PlanStep(
                        action="SQL_SEARCH",
                        params={
                            "project": facts.project,
                            "version": facts.version,
                            "mpu_name": facts.mpu_name,
                        },
                    )
                ],
            )

        # fallback
        return ExecutionPlan(
            reason="Unstructured query",
            steps=[
                PlanStep(
                    action="VECTOR_SEARCH",
                    params={
                        "query_text": facts.raw_text,
                        "filters": {},
                    }
                )
            ],
        )






def build_policy_context(classified_policies: list[dict]) -> str:
    lines = []

    for p in classified_policies:
        lines.append(f"""
Project: {p['project']}
Version: {p['version']}
MPU: {p['mpu_name']}
Region: {p['region']}
Profile: {p['profile']}
Policy Type: {p['policy_type']}

Explanation:
{p['explanation']}
""")

    return "\n---\n".join(lines)



def classify_policy(start: int, end: int, profile: str) -> dict:
    if start == 0xFFFFFFFF and end == 0xFFFFFFFF:
        if profile and profile.upper() == "NON_STATIC":
            return {
                "policy_type": "RUNTIME_PROGRAMMED",
                "address": None,
                "explanation": "Address will be programmed by software at runtime"
            }
        else:
            return {
                "policy_type": "UNUSED_POLICY",
                "address": None,
                "explanation": "Unused MPU policy (address intentionally not defined)"
            }

    return {
        "policy_type": "ADDRESS_DEFINED",
        "address": f"{hex(start)} - {hex(end)}",
        "explanation": "Statically defined address range"
    }



def ask_llm(question: str, vector_rows: list[dict], llm_client) -> str:
    context = build_llm_context(vector_rows)

    messages = [
        {"role": "system", "content": SYSTEM_PROMPT},
        {
            "role": "user",
            "content": USER_PROMPT_TEMPLATE.format(
                question=question,
                context=context
            )
        }
    ]

    response = llm_client.chat.completions.create(
        model="gpt-4o-mini",   # or your QGenie chat model
        messages=messages,
        temperature=0.0        # IMPORTANT for factual answers
    )

    return response.choices[0].message.content


SYSTEM_PROMPT = """
You are a low-level SoC security expert.
You MUST answer using ONLY the provided context.
If an address is not present, say "Address not defined".
Never invent addresses or MPU names.
"""

USER_PROMPT_TEMPLATE = """
User Question:
{question}

Context (MPU regions retrieved from database):
{context}

Instructions:
- Answer in plain English
- Clearly list address ranges
- Group by MPU name
- If multiple regions exist, list them in ascending region index order
"""






def vector_search(
    self,
    query_vector: list[float],
    project: str | None = None,
    version: str | None = None,
    limit: int = 5,
):
    where_clauses = []
    params = []

    # ---- scope rules ----
    if project:
        where_clauses.append("project = %s")
        params.append(project)

    if version:
        where_clauses.append("version = %s")
        params.append(version)
    else:
        where_clauses.append("is_latest = true")

    where_sql = " AND ".join(where_clauses)

    sql = f"""
        SELECT
            id,
            project,
            version,
            raw_text,
            embedding <=> %s::vector AS distance
        FROM xml_chunks
        WHERE {where_sql}
        ORDER BY embedding <=> %s::vector
        LIMIT %s
    """

    with psycopg2.connect(PG_DSN) as conn:
        with conn.cursor() as cur:
            cur.execute(
                sql,
                [query_vector] + params + [query_vector, limit]
            )
            return cur.fetchall()









from typing import Tuple, Optional, Union

def normalize_version(v: Optional[Union[str, tuple]]) -> Tuple[int, ...]:
    """
    Normalize version into a comparable tuple.
    Safe against None, tuple, 'v5.3', '5.3-beta'.
    """

    if v is None:
        return ()

    # Handle psycopg2 tuple like ('5.3',)
    if isinstance(v, tuple):
        if len(v) == 1:
            v = v[0]
        else:
            raise ValueError(f"Invalid version tuple: {v}")

    if not isinstance(v, str):
        raise TypeError(f"Version must be string, got {type(v)}")

    v = v.strip().lower()

    # Remove leading 'v'
    if v.startswith("v"):
        v = v[1:]

    parts = []
    for p in v.split("."):
        # strip non-numeric suffixes: 5, 5-beta â†’ 5
        num = ""
        for c in p:
            if c.isdigit():
                num += c
            else:
                break
        if num:
            parts.append(int(num))

    return tuple(parts)





def build_semantic_chunk(self, region: ParsedRegion) -> str:
    lines = []

    if region.mpu_name:
        lines.append(f"This MPU region belongs to {region.mpu_name}.")

    lines.append("This region defines access-control policy for a memory range.")

    if region.read_domains:
        lines.append(
            f"Read access is allowed to the following domains: {', '.join(region.read_domains)}."
        )
    else:
        lines.append("Read access is not explicitly defined.")

    if region.write_domains:
        lines.append(
            f"Write access is allowed to the following domains: {', '.join(region.write_domains)}."
        )
    else:
        lines.append("Write access is not explicitly defined.")

    if region.profile:
        lines.append(f"This policy applies under the {region.profile} execution profile.")

    if region.raw_text:
        lines.append("Additional policy details:")
        lines.append(region.raw_text)

    return " ".join(lines)



User Query
   â†“
HyDE rewrite (natural language intent)
   â†“
STRUCTURED FACT EXTRACTION  âœ…  â† instructor
   â†“
SQL filter + vector search

from typing import Optional, List
from pydantic import BaseModel, Field

class PolicyQuery(BaseModel):
    project: Optional[str] = Field(None, description="SoC / platform name")
    version: Optional[str] = Field(None, description="Platform version")
    mpu_name: Optional[str] = Field(None, description="MPU name")

    addr_start: Optional[int] = Field(None, description="Hex address start")
    addr_end: Optional[int] = Field(None, description="Hex address end")

    read_domains: Optional[List[str]] = None
    write_domains: Optional[List[str]] = None

    profile: Optional[str] = None

import instructor
from openai import OpenAI

client = instructor.from_openai(OpenAI())

def extract_query_facts(user_query: str, hyde_text: str) -> PolicyQuery:
    return client.chat.completions.create(
        model="gpt-4o-mini",
        response_model=PolicyQuery,
        temperature=0,
        messages=[
            {
                "role": "system",
                "content": (
                    "Extract MPU access-control query constraints.\n"
                    "Do NOT guess values.\n"
                    "Only include fields explicitly mentioned or clearly implied.\n"
                    "Hex addresses must be converted to integers.\n"
                )
            },
            {
                "role": "user",
                "content": f"""
User query:
{user_query}

HyDE interpretation:
{hyde_text}
"""
            }
        ],
    )

Give me policy for address 0x1D320000 in kaanapalli project
PolicyQuery(
    project="KAANAPALLI",
    addr_start=0x1D320000,
    addr_end=0x1D320000
)



from typing import Optional, List
from pydantic import BaseModel, Field, model_validator

class PolicyQuery(BaseModel):
    # ---- identifiers ----
    project: Optional[str] = None
    version: Optional[str] = None
    mpu_name: Optional[str] = None

    # ---- address ----
    addr_start: Optional[int] = None
    addr_end: Optional[int] = None

    # ---- access ----
    read_domains: Optional[List[str]] = None
    write_domains: Optional[List[str]] = None

    profile: Optional[str] = None

    # ---- diagnostics ----
    missing_context: Optional[str] = Field(
        None,
        description="Explains what mandatory context is missing, if any"
    )

Add conditional validation logic

This is the key part ðŸ‘‡

    @model_validator(mode="after")
    def validate_context_requirements(self):
        address_query = self.addr_start is not None or self.addr_end is not None
        mpu_query = self.mpu_name is not None

        if address_query or mpu_query:
            if not (self.project or self.version):
                self.missing_context = (
                    "Project or version is required when querying by "
                    "address or MPU name."
                )

        return self

If required context (project or version) is missing,
leave the field empty and explain it in `missing_context`.
Do NOT guess.



Give me policy for address 0x1D320000 in Kaanapalli

Give me policy for address 0x1D320000
What is the policy for AOSS_PERIPH_MPU_XPU4?


query = extract_query_facts(user_query, hyde_text)

if query.missing_context:
    return {
        "status": "need_more_info",
        "message": query.missing_context
    }

# Safe to proceed
sql_where, params = build_sql_filters(query)

if address_query and not (self.project or self.version):
    raise ValueError("Project or version required for address queries")


logger.debug(
    "PRTN index=%s start=%s end=%s rdomains=%s wdomains=%s",
    prtn.get("index"),
    start_raw,
    end_raw,
    prtn.get("rdomains"),
    prtn.get("wdomains"),
)


str:
        return (
            "ParsedRegion("
            f"project={self.project}, "
            f"version={self.version}, "
            f"mpu={self.mpu_name}, "
            f"rg_index={self.rg_index}, "
            f"addr=0x{self.addr_start:X}-0x{self.addr_end:X}, "
            f"profile={self.profile or 'âˆ…'}, "
            f"read_domains={self.read_domains}, "
            f"write_domains={self.write_domains}"
            ")"
        )


def debug_print_region(region, prefix="REGION"):
    print(f"\n[{prefix}]")
    print(f"  project      : {region.project}")
    print(f"  version      : {region.version}")
    print(f"  mpu_name     : {region.mpu_name}")
    print(f"  rg_index     : {region.rg_index}")
    print(f"  addr_start   : {hex(region.addr_start) if region.addr_start is not None else None}")
    print(f"  addr_end     : {hex(region.addr_end) if region.addr_end is not None else None}")
    print(f"  profile      : {getattr(region, 'profile', None)}")
    print(f"  read_domains : {region.read_domains} (type={type(region.read_domains)})")
    print(f"  write_domains: {region.write_domains} (type={type(region.write_domains)})")
    print(f"  raw_text     : {region.raw_text[:120]}...")

def compute_chunk_hash(region: ParsedRegion) -> str:
    h = hashlib.sha256()
    h.update(region.project.encode())
    h.update(region.version.encode())
    h.update(region.mpu_name.encode())
    h.update(str(region.rg_index).encode())
    h.update(str(region.addr_start).encode())
    h.update(str(region.addr_end).encode())
    h.update(region.profile.encode())
    h.update(region.raw_text.encode())
    return h.hexdigest()

def embed_and_store(
    conn,
    embed_fn,
    regions: list,
):
    """
    conn      : psycopg2 connection
    embed_fn  : callable(text) -> list[float]
    regions   : list[ParsedRegion]
    """

    sql = """
    INSERT INTO policy_chunks (
        project,
        version,
        mpu_name,
        rg_index,
        addr_start,
        addr_end,
        read_domains,
        write_domains,
        raw_text,
        embedding
    )
    VALUES (
        %(project)s,
        %(version)s,
        %(mpu_name)s,
        %(rg_index)s,
        %(addr_start)s,
        %(addr_end)s,
        %(read_domains)s,
        %(write_domains)s,
        %(raw_text)s,
        %(embedding)s
    )
    """

    with conn.cursor() as cur:
        for region in regions:
            # ---------- hard safety checks ----------
            if region.addr_start is None or region.addr_end is None:
                continue

            if region.addr_start > region.addr_end:
                continue

            # ---------- build semantic text ----------
            embed_text = build_embedding_text(region)

            # ---------- generate vector ----------
            embedding = embed_fn(embed_text)

            # ---------- store ----------
            cur.execute(
                sql,
                {
                    "project": region.project,
                    "version": region.version,
                    "mpu_name": region.mpu_name,
                    "rg_index": region.rg_index,
                    "addr_start": region.addr_start,
                    "addr_end": region.addr_end,
                    "read_domains": region.read_domains or [],
                    "write_domains": region.write_domains or [],
                    "raw_text": region.raw_text,
                    "embedding": embedding,
                },
            )

        conn.commit()








import re
from typing import Optional
from dataclasses import dataclass


@dataclass(frozen=True)
class QueryFacts:
    project: Optional[str] = None
    version: Optional[str] = None
    addr: Optional[int] = None
    mpu: Optional[str] = None


# --- regex ---
HEX_ADDR_RE = re.compile(r"0x[0-9a-fA-F]+")
VERSION_RE = re.compile(r"\b(\d+\.\d+)\b")
PROJECT_RE = re.compile(r"\b(KAANAPALLI|HAWI|WAIPIO|KAILUA)\b", re.I)
MPU_RE = re.compile(r"\b[A-Z0-9_]+_MPU_[A-Z0-9_]+\b", re.I)


def extract_query_facts(user_query: str) -> QueryFacts:
    text = user_query.upper()

    # Address
    addr = None
    m = HEX_ADDR_RE.search(text)
    if m:
        addr = int(m.group(), 16)

    # Version
    version = None
    m = VERSION_RE.search(text)
    if m:
        version = m.group(1)

    # Project
    project = None
    m = PROJECT_RE.search(text)
    if m:
        project = m.group(1)

    # MPU
    mpu = None
    m = MPU_RE.search(text)
    if m:
        mpu = m.group()

    return QueryFacts(
        project=project,
        version=version,
        addr=addr,
        mpu=mpu,
    )

def generate_hyde_text(
    user_query: str,
    facts: QueryFacts,
    llm,
) -> str:
    """
    Generate HyDE-style technical rewrite for embedding only.
    Output is NOT used for SQL.
    """

    system_prompt = """
You rewrite user questions into precise technical search statements.

Rules:
- Do NOT invent MPU names, addresses, or permissions
- Use only provided facts
- Write in neutral, technical language
- One paragraph only
"""

    constraints = []

    if facts.project:
        constraints.append(f"Project: {facts.project}")
    if facts.version:
        constraints.append(f"Version: {facts.version}")
    if facts.mpu:
        constraints.append(f"MPU: {facts.mpu}")
    if facts.addr is not None:
        constraints.append(f"Address: 0x{facts.addr:X}")

    constraint_text = "\n".join(constraints)

    user_prompt = f"""
Original query:
{user_query}

Known facts:
{constraint_text}

Rewrite as a technical statement describing the MPU access-control policy being queried.
"""

    rewritten = llm.ask(
        prompt=user_prompt,
        system_prompt=system_prompt,
        temperature=0.0,   # critical: no creativity
        max_tokens=120,
    )

    return rewritten.strip()














def build_chunk_text(
    *,
    project: str | None,
    version: str | None,
    mpu_name: str | None,
    region_index: int | None,
    addr_start: int | None,
    addr_end: int | None,
    policy_text: str,
) -> str:
    """
    Build embedding-optimized chunk text with structured metadata labels.

    This text is ONLY for embedding + vector search.
    """

    labels = []

    if project:
        labels.append(f"[PROJECT={project}]")

    if version:
        labels.append(f"[VERSION={version}]")

    if mpu_name:
        labels.append(f"[MPU={mpu_name}]")

    if region_index is not None:
        labels.append(f"[REGION={region_index}]")

    if addr_start is not None:
        labels.append(f"[ADDR_START=0x{addr_start:X}]")

    if addr_end is not None:
        labels.append(f"[ADDR_END=0x{addr_end:X}]")

    # ---- final chunk text ----
    # metadata first, policy content second
    chunk_text = "\n".join(labels)
    chunk_text += "\n\n"
    chunk_text += policy_text.strip()

    return chunk_text



You are a technical query rewriter for a retrieval system.

Your task:
Rewrite the user query into a precise technical statement that describes
an MPU access-control policy.

Rules:
- Do NOT answer the question
- Do NOT explain concepts
- Do NOT invent values
- Only restate the query as a factual policy description
- Use the same metadata labels used during ingestion when possible

Allowed labels (use only if mentioned or clearly implied):
[PROJECT=...]
[VERSION=...]
[MPU=...]
[REGION=...]
[ADDR_START=0x...]
[ADDR_END=0x...]

If an exact value is not known, omit the label.

The output must be a short technical paragraph, not bullet points.




# Step 1: vector recall
candidate_ids = vector_search(query_embedding)

# Step 2: SQL truth filter
rows = sql_fetch(
    candidate_ids=candidate_ids,
    project=project,
    version=latest,
    address=query_address
)

# Step 3: rank + explain
ranked = rerank(rows)




filters = {
    "candidate_chunk_ids": [12, 47, 103, 208],
    "project": "KAANAPALLI",
    "version": "latest",
    "mpu_name": None,
    "region": None,
    "query_address": 0xC210000,
}

output expected 

SELECT ...
FROM policy_chunks
WHERE id = ANY(%(candidate_chunk_ids)s)
  AND project = %(project)s
  AND version = (
        SELECT MAX(version)
        FROM policy_chunks
        WHERE project = %(project)s
  )
  AND addr_start <= %(query_address)s
  AND addr_end >= %(query_address)s

{
  "candidate_chunk_ids": [12, 47, 103, 208],
  "project": "KAANAPALLI",
  "query_address": 0xC210000
}










def build_policy_sql(filters: dict) -> tuple[str, dict]:
    """
    Build a safe, parameterized SQL query for policy retrieval.

    Expected filters keys:
      - candidate_chunk_ids: list[int] (REQUIRED)
      - project: str | None
      - version: str | "latest" | None
      - mpu_name: str | None
      - region: int | None
      - query_address: int | None

    Returns:
      (sql_query, sql_params)
    """

    if not filters.get("candidate_chunk_ids"):
        raise ValueError("candidate_chunk_ids is required for SQL filtering")

    where_clauses = []
    params = {}

    # --- Candidate gating (mandatory) ---
    where_clauses.append("id = ANY(%(candidate_chunk_ids)s)")
    params["candidate_chunk_ids"] = filters["candidate_chunk_ids"]

    # --- Project ---
    if filters.get("project"):
        where_clauses.append("project = %(project)s")
        params["project"] = filters["project"]

    # --- Version ---
    version = filters.get("version")
    if version and version != "latest":
        where_clauses.append("version = %(version)s")
        params["version"] = version
    elif version == "latest":
        where_clauses.append(
            "version = (SELECT MAX(version) FROM policy_chunks WHERE project = %(project)s)"
        )
        params["project"] = filters.get("project")

    # --- MPU ---
    if filters.get("mpu_name"):
        where_clauses.append("mpu_name = %(mpu_name)s")
        params["mpu_name"] = filters["mpu_name"]

    # --- Region ---
    if filters.get("region") is not None:
        where_clauses.append("rg_index = %(region)s")
        params["region"] = filters["region"]

    # --- Address containment ---
    if filters.get("query_address") is not None:
        where_clauses.append(
            "(addr_start <= %(query_address)s AND addr_end >= %(query_address)s)"
        )
        params["query_address"] = filters["query_address"]

    # --- Final SQL ---
    sql = f"""
        SELECT
            id,
            project,
            version,
            mpu_name,
            rg_index,
            addr_start,
            addr_end,
            raw_text,
            embedding
        FROM policy_chunks
        WHERE {" AND ".join(where_clauses)}
    """

    return sql.strip(), params
