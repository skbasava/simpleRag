import psycopg2
from typing import List, Dict, Any

def execute_hybrid_search(
    *,
    conn,
    embed_fn,
    params: Dict[str, Any],
) -> List[dict]:
    """
    Hybrid search = SQL narrowing + vector ranking
    """

    sql_filters = params["sql_filters"]
    semantic_query = params["semantic_query"]
    limit = params.get("limit", 5)

    # ------------------------
    # Step 1: SQL narrowing
    # ------------------------
    where_clauses = []
    values = []

    if "project" in sql_filters:
        where_clauses.append("project = %s")
        values.append(sql_filters["project"])

    if "version" in sql_filters:
        where_clauses.append("version = %s")
        values.append(sql_filters["version"])

    if "addr_contains" in sql_filters:
        addr = int(sql_filters["addr_contains"], 16)
        where_clauses.append("addr_start <= %s AND addr_end >= %s")
        values.extend([addr, addr])

    where_sql = " AND ".join(where_clauses) or "TRUE"

    base_sql = f"""
        SELECT
            id,
            project,
            version,
            raw_text,
            embedding
        FROM xml_chunks
        WHERE {where_sql}
    """

    with conn.cursor() as cur:
        cur.execute(base_sql, values)
        candidates = cur.fetchall()

    if not candidates:
        return []

    # ------------------------
    # Step 2: Vector ranking
    # ------------------------
    query_embedding = embed_fn(semantic_query)

    rank_sql = """
        SELECT
            id,
            project,
            version,
            raw_text,
            embedding <=> %s::vector AS distance
        FROM xml_chunks
        WHERE id = ANY(%s)
        ORDER BY embedding <=> %s::vector
        LIMIT %s
    """

    candidate_ids = [row[0] for row in candidates]

    with conn.cursor() as cur:
        cur.execute(
            rank_sql,
            (query_embedding, candidate_ids, query_embedding, limit)
        )
        rows = cur.fetchall()

    return [
        {
            "id": r[0],
            "project": r[1],
            "version": r[2],
            "raw_text": r[3],
            "score": float(r[4]),
        }
        for r in rows
    ]



def execute_plan_step(step, *, conn, embed_fn):
    action = step["action"]
    params = step["params"]

    if action == "HYBRID_SEARCH":
        return execute_hybrid_search(
            conn=conn,
            embed_fn=embed_fn,
            params=params,
        )

    if action == "VECTOR_SEARCH":
        raise NotImplementedError("Use HYBRID_SEARCH instead")

    if action == "CLARIFY":
        return {"clarify": params["question"]}

    raise ValueError(f"Unknown action {action}")








from pydantic import BaseModel, Field
from typing import Optional


class QueryFacts(BaseModel):
    intent: str = Field(
        description="High-level intent such as ADDRESS_LOOKUP, POLICY_LOOKUP"
    )

    project: Optional[str] = Field(
        None, description="SoC / project name"
    )

    version: Optional[str] = Field(
        None, description="Platform version. Null means latest"
    )

    mpu_name: Optional[str] = Field(
        None, description="MPU name if explicitly mentioned"
    )

    addr_start: Optional[int] = Field(
        None, description="Start address as integer"
    )

    addr_end: Optional[int] = Field(
        None, description="End address if available"
    )

    profile: Optional[str] = Field(
        None, description="Security profile like TME_FW, TZ, XBL"
    )


def extract_query_facts(
    ins_client,
    user_query: str,
    hyde_text: str,
) -> QueryFacts:
    """
    Extract structured query facts using Instructor.
    This function does NOT plan queries.
    """

    return ins_client.chat.completions.create(
        model="Turbo",
        response_model=QueryFacts,
        temperature=0,
        messages=[
            {
                "role": "system",
                "content": """
You extract structured MPU access-control query facts.

Rules:
- Use HyDE interpretation as authoritative context.
- Do NOT invent values.
- If a value is missing or unclear, return null.
- Convert hex addresses to integers.
- If project or address is explicitly stated in HyDE, you MUST extract it.
- If version is not mentioned, return null.
"""
            },
            {
                "role": "user",
                "content": f"""
User query:
{user_query}

HyDE interpretation:
{hyde_text}
"""
            }
        ],
    )





import json
import logging

logger = logging.getLogger("query_planner")
logger.setLevel(logging.INFO)


def log_plans(plans: list[QueryPlan], *, stage: str):
    logger.info(
        "[QUERY_PLANS] stage=%s plans=%s",
        stage,
        json.dumps([p.to_log() for p in plans], indent=2),
    )


class Planner:

    def plan(self, facts: Facts) -> list[QueryPlan]:
        plans = []
        qid = 1

        # ---- missing project → clarification ----
        if not facts.project:
            return [
                QueryPlan(
                    id=qid,
                    action="CLARIFY",
                    params={"question": "Which project is this policy for?"}
                )
            ]

        version = facts.version or "latest"

        # ---- ADDRESS based ----
        if facts.intent == "ADDRESS":
            plans.append(
                QueryPlan(
                    id=qid,
                    action="VECTOR_SEARCH",
                    params={
                        "keywords": [facts.address],
                        "filters": {
                            "project": facts.project,
                            "version": version
                        }
                    }
                )
            )
            qid += 1

        # ---- POLICY by MPU ----
        if facts.intent == "POLICY":
            if not facts.mpu_name:
                return [
                    QueryPlan(
                        id=qid,
                        action="CLARIFY",
                        params={"question": "Which MPU name is this policy for?"}
                    )
                ]

            plans.append(
                QueryPlan(
                    id=qid,
                    action="VECTOR_SEARCH",
                    params={
                        "keywords": [facts.mpu_name],
                        "filters": {
                            "project": facts.project,
                            "version": version,
                            "profile": facts.profile
                        }
                    }
                )
            )

        return plans







You are a query planner for an MPU access control policy system.

Your job is to extract structured query intent from a user question.

Rules:
1. Identify project names if mentioned. If not mentioned, mark project as MISSING.
2. Identify version if mentioned. If not, assume "latest".
3. Identify MPU name if mentioned.
4. Identify address if mentioned (single address, not range).
5. Identify profile if mentioned (TZ, MSA, TME_FW, HYP). Empty means TZ.
6. Decide the query intent type:
   - ADDRESS_LOOKUP (address → policy)
   - MPU_POLICY (policy for MPU)
   - COMPARE (compare across projects or versions)

Do NOT answer the question.
Do NOT generate SQL.
Do NOT generate embeddings.

Return ONLY structured data matching the schema.



from pydantic import BaseModel
from typing import Optional, List, Literal

QueryIntent = Literal[
    "ADDRESS_LOOKUP",
    "MPU_POLICY",
    "COMPARE"
]

class PlannedQuery(BaseModel):
    intent: QueryIntent

    project: Optional[str] = None
    version: Optional[str] = "latest"

    mpu_name: Optional[str] = None
    address: Optional[str] = None  # hex string like 0x1D320000

    profile: Optional[str] = None  # TZ, MSA, TME_FW, etc.

    compare_projects: Optional[List[str]] = None
    compare_versions: Optional[List[str]] = None

def execute_planned_query(plan: PlannedQuery):
    # 1. Resolve missing context
    if plan.project is None and plan.intent != "COMPARE":
        return ask_user_for_project()

    # 2. Build vector query (HyDE already done)
    vector_candidates = vector_search(
        text=hyde_text,
        top_k=50
    )

    # 3. Build SQL filters from planner output
    sql_filters = {
        "project": plan.project,
        "version": plan.version,
        "mpu_name": plan.mpu_name,
        "profile": plan.profile,
        "address": plan.address,
        "chunk_ids": [c.id for c in vector_candidates],
    }

    sql_rows = run_sql(sql_filters)

    return sql_rows



from typing import Optional, Literal
from pydantic import BaseModel
import re

# -------------------------
# Models
# -------------------------

QueryIntent = Literal[
    "ADDRESS_LOOKUP",
    "MPU_POLICY",
    "COMPARE"
]

class PlannedQuery(BaseModel):
    intent: QueryIntent
    project: Optional[str] = None
    version: str = "latest"
    mpu_name: Optional[str] = None
    address: Optional[str] = None
    profile: Optional[str] = None


class Clarification(BaseModel):
    needs_clarification: bool
    question: str


# -------------------------
# Query Planner
# -------------------------

class QueryPlanner:
    """
    Text-only planner.
    Does NOT run vector search.
    Does NOT run SQL.
    """

    PROJECT_PATTERN = re.compile(r"\b(project\s+)?([a-zA-Z0-9_-]+)\b", re.I)
    ADDR_PATTERN = re.compile(r"0x[0-9a-fA-F]{6,8}")
    VERSION_PATTERN = re.compile(r"version\s+([\d.]+)", re.I)
    MPU_PATTERN = re.compile(r"\bMPU[_\w]+\b", re.I)

    def plan(self, user_query: str, hyde_text: str) -> PlannedQuery:
        text = f"{user_query}\n{hyde_text}"

        address = self._extract_address(text)
        project = self._extract_project(text)
        version = self._extract_version(text) or "latest"
        mpu = self._extract_mpu(text)

        intent = self._infer_intent(address, mpu, user_query)

        return PlannedQuery(
            intent=intent,
            project=project,
            version=version,
            mpu_name=mpu,
            address=address
        )

    def validate(self, plan: PlannedQuery):
        if plan.intent == "ADDRESS_LOOKUP" and not plan.project:
            return Clarification(
                needs_clarification=True,
                question="Which project should I search this address in?"
            )

        if plan.intent == "MPU_POLICY" and not plan.project:
            return Clarification(
                needs_clarification=True,
                question="Please specify the project for the MPU policy lookup."
            )

        return None

    # -------------------------
    # Extractors
    # -------------------------

    def _extract_address(self, text):
        m = self.ADDR_PATTERN.search(text)
        return m.group(0) if m else None

    def _extract_version(self, text):
        m = self.VERSION_PATTERN.search(text)
        return m.group(1) if m else None

    def _extract_mpu(self, text):
        m = self.MPU_PATTERN.search(text)
        return m.group(0) if m else None

    def _extract_project(self, text):
        # Very conservative: require explicit "project <name>"
        m = re.search(r"project\s+([a-zA-Z0-9_-]+)", text, re.I)
        return m.group(1) if m else None

    def _infer_intent(self, address, mpu, query):
        if address:
            return "ADDRESS_LOOKUP"
        if mpu:
            return "MPU_POLICY"
        if "compare" in query.lower():
            return "COMPARE"
        return "MPU_POLICY"


# -------------------------
# Example usage
# -------------------------

if __name__ == "__main__":
    planner = QueryPlanner()

    user_query = "Give me policy for address 0x1D320000 in kaanapalli"
    hyde_text = (
        "MPU access control policy lookup for address 0x1D320000 "
        "in kaanapalli SoC subsystem."
    )

    plan = planner.plan(user_query, hyde_text)
    clarification = planner.validate(plan)

    if clarification:
        print(clarification.json(indent=2))
    else:
        print(plan.json(indent=2))